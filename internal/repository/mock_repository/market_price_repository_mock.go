package mock_repository

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/abrbird/portfolio_bot/internal/repository.MarketPriceRepository -o ./market_price_repository_mock_test.go -n MarketPriceRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/abrbird/portfolio_bot/internal/domain"
)

// MarketPriceRepositoryMock implements MarketPriceRepository
type MarketPriceRepositoryMock struct {
	t minimock.Tester

	funcBulkCreate          func(ctx context.Context, marketPrices *[]domain.MarketPrice) (i1 int64, err error)
	inspectFuncBulkCreate   func(ctx context.Context, marketPrices *[]domain.MarketPrice)
	afterBulkCreateCounter  uint64
	beforeBulkCreateCounter uint64
	BulkCreateMock          mMarketPriceRepositoryMockBulkCreate

	funcCreate          func(ctx context.Context, marketPrice *domain.MarketPrice) (b1 bool, err error)
	inspectFuncCreate   func(ctx context.Context, marketPrice *domain.MarketPrice)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mMarketPriceRepositoryMockCreate

	funcRetrieveInterval          func(ctx context.Context, marketItemId int64, start int64, end int64) (mp1 *domain.MarketPricesRetrieve)
	inspectFuncRetrieveInterval   func(ctx context.Context, marketItemId int64, start int64, end int64)
	afterRetrieveIntervalCounter  uint64
	beforeRetrieveIntervalCounter uint64
	RetrieveIntervalMock          mMarketPriceRepositoryMockRetrieveInterval

	funcRetrieveLast          func(ctx context.Context, marketItemId int64) (m1 domain.MarketPriceRetrieve)
	inspectFuncRetrieveLast   func(ctx context.Context, marketItemId int64)
	afterRetrieveLastCounter  uint64
	beforeRetrieveLastCounter uint64
	RetrieveLastMock          mMarketPriceRepositoryMockRetrieveLast
}

// NewMarketPriceRepositoryMock returns a mock for MarketPriceRepository
func NewMarketPriceRepositoryMock(t minimock.Tester) *MarketPriceRepositoryMock {
	m := &MarketPriceRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BulkCreateMock = mMarketPriceRepositoryMockBulkCreate{mock: m}
	m.BulkCreateMock.callArgs = []*MarketPriceRepositoryMockBulkCreateParams{}

	m.CreateMock = mMarketPriceRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*MarketPriceRepositoryMockCreateParams{}

	m.RetrieveIntervalMock = mMarketPriceRepositoryMockRetrieveInterval{mock: m}
	m.RetrieveIntervalMock.callArgs = []*MarketPriceRepositoryMockRetrieveIntervalParams{}

	m.RetrieveLastMock = mMarketPriceRepositoryMockRetrieveLast{mock: m}
	m.RetrieveLastMock.callArgs = []*MarketPriceRepositoryMockRetrieveLastParams{}

	return m
}

type mMarketPriceRepositoryMockBulkCreate struct {
	mock               *MarketPriceRepositoryMock
	defaultExpectation *MarketPriceRepositoryMockBulkCreateExpectation
	expectations       []*MarketPriceRepositoryMockBulkCreateExpectation

	callArgs []*MarketPriceRepositoryMockBulkCreateParams
	mutex    sync.RWMutex
}

// MarketPriceRepositoryMockBulkCreateExpectation specifies expectation struct of the MarketPriceRepository.BulkCreate
type MarketPriceRepositoryMockBulkCreateExpectation struct {
	mock    *MarketPriceRepositoryMock
	params  *MarketPriceRepositoryMockBulkCreateParams
	results *MarketPriceRepositoryMockBulkCreateResults
	Counter uint64
}

// MarketPriceRepositoryMockBulkCreateParams contains parameters of the MarketPriceRepository.BulkCreate
type MarketPriceRepositoryMockBulkCreateParams struct {
	ctx          context.Context
	marketPrices *[]domain.MarketPrice
}

// MarketPriceRepositoryMockBulkCreateResults contains results of the MarketPriceRepository.BulkCreate
type MarketPriceRepositoryMockBulkCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for MarketPriceRepository.BulkCreate
func (mmBulkCreate *mMarketPriceRepositoryMockBulkCreate) Expect(ctx context.Context, marketPrices *[]domain.MarketPrice) *mMarketPriceRepositoryMockBulkCreate {
	if mmBulkCreate.mock.funcBulkCreate != nil {
		mmBulkCreate.mock.t.Fatalf("MarketPriceRepositoryMock.BulkCreate mock is already set by Set")
	}

	if mmBulkCreate.defaultExpectation == nil {
		mmBulkCreate.defaultExpectation = &MarketPriceRepositoryMockBulkCreateExpectation{}
	}

	mmBulkCreate.defaultExpectation.params = &MarketPriceRepositoryMockBulkCreateParams{ctx, marketPrices}
	for _, e := range mmBulkCreate.expectations {
		if minimock.Equal(e.params, mmBulkCreate.defaultExpectation.params) {
			mmBulkCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBulkCreate.defaultExpectation.params)
		}
	}

	return mmBulkCreate
}

// Inspect accepts an inspector function that has same arguments as the MarketPriceRepository.BulkCreate
func (mmBulkCreate *mMarketPriceRepositoryMockBulkCreate) Inspect(f func(ctx context.Context, marketPrices *[]domain.MarketPrice)) *mMarketPriceRepositoryMockBulkCreate {
	if mmBulkCreate.mock.inspectFuncBulkCreate != nil {
		mmBulkCreate.mock.t.Fatalf("Inspect function is already set for MarketPriceRepositoryMock.BulkCreate")
	}

	mmBulkCreate.mock.inspectFuncBulkCreate = f

	return mmBulkCreate
}

// Return sets up results that will be returned by MarketPriceRepository.BulkCreate
func (mmBulkCreate *mMarketPriceRepositoryMockBulkCreate) Return(i1 int64, err error) *MarketPriceRepositoryMock {
	if mmBulkCreate.mock.funcBulkCreate != nil {
		mmBulkCreate.mock.t.Fatalf("MarketPriceRepositoryMock.BulkCreate mock is already set by Set")
	}

	if mmBulkCreate.defaultExpectation == nil {
		mmBulkCreate.defaultExpectation = &MarketPriceRepositoryMockBulkCreateExpectation{mock: mmBulkCreate.mock}
	}
	mmBulkCreate.defaultExpectation.results = &MarketPriceRepositoryMockBulkCreateResults{i1, err}
	return mmBulkCreate.mock
}

//Set uses given function f to mock the MarketPriceRepository.BulkCreate method
func (mmBulkCreate *mMarketPriceRepositoryMockBulkCreate) Set(f func(ctx context.Context, marketPrices *[]domain.MarketPrice) (i1 int64, err error)) *MarketPriceRepositoryMock {
	if mmBulkCreate.defaultExpectation != nil {
		mmBulkCreate.mock.t.Fatalf("Default expectation is already set for the MarketPriceRepository.BulkCreate method")
	}

	if len(mmBulkCreate.expectations) > 0 {
		mmBulkCreate.mock.t.Fatalf("Some expectations are already set for the MarketPriceRepository.BulkCreate method")
	}

	mmBulkCreate.mock.funcBulkCreate = f
	return mmBulkCreate.mock
}

// When sets expectation for the MarketPriceRepository.BulkCreate which will trigger the result defined by the following
// Then helper
func (mmBulkCreate *mMarketPriceRepositoryMockBulkCreate) When(ctx context.Context, marketPrices *[]domain.MarketPrice) *MarketPriceRepositoryMockBulkCreateExpectation {
	if mmBulkCreate.mock.funcBulkCreate != nil {
		mmBulkCreate.mock.t.Fatalf("MarketPriceRepositoryMock.BulkCreate mock is already set by Set")
	}

	expectation := &MarketPriceRepositoryMockBulkCreateExpectation{
		mock:   mmBulkCreate.mock,
		params: &MarketPriceRepositoryMockBulkCreateParams{ctx, marketPrices},
	}
	mmBulkCreate.expectations = append(mmBulkCreate.expectations, expectation)
	return expectation
}

// Then sets up MarketPriceRepository.BulkCreate return parameters for the expectation previously defined by the When method
func (e *MarketPriceRepositoryMockBulkCreateExpectation) Then(i1 int64, err error) *MarketPriceRepositoryMock {
	e.results = &MarketPriceRepositoryMockBulkCreateResults{i1, err}
	return e.mock
}

// BulkCreate implements MarketPriceRepository
func (mmBulkCreate *MarketPriceRepositoryMock) BulkCreate(ctx context.Context, marketPrices *[]domain.MarketPrice) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmBulkCreate.beforeBulkCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmBulkCreate.afterBulkCreateCounter, 1)

	if mmBulkCreate.inspectFuncBulkCreate != nil {
		mmBulkCreate.inspectFuncBulkCreate(ctx, marketPrices)
	}

	mm_params := &MarketPriceRepositoryMockBulkCreateParams{ctx, marketPrices}

	// Record call args
	mmBulkCreate.BulkCreateMock.mutex.Lock()
	mmBulkCreate.BulkCreateMock.callArgs = append(mmBulkCreate.BulkCreateMock.callArgs, mm_params)
	mmBulkCreate.BulkCreateMock.mutex.Unlock()

	for _, e := range mmBulkCreate.BulkCreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmBulkCreate.BulkCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBulkCreate.BulkCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmBulkCreate.BulkCreateMock.defaultExpectation.params
		mm_got := MarketPriceRepositoryMockBulkCreateParams{ctx, marketPrices}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBulkCreate.t.Errorf("MarketPriceRepositoryMock.BulkCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBulkCreate.BulkCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmBulkCreate.t.Fatal("No results are set for the MarketPriceRepositoryMock.BulkCreate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmBulkCreate.funcBulkCreate != nil {
		return mmBulkCreate.funcBulkCreate(ctx, marketPrices)
	}
	mmBulkCreate.t.Fatalf("Unexpected call to MarketPriceRepositoryMock.BulkCreate. %v %v", ctx, marketPrices)
	return
}

// BulkCreateAfterCounter returns a count of finished MarketPriceRepositoryMock.BulkCreate invocations
func (mmBulkCreate *MarketPriceRepositoryMock) BulkCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBulkCreate.afterBulkCreateCounter)
}

// BulkCreateBeforeCounter returns a count of MarketPriceRepositoryMock.BulkCreate invocations
func (mmBulkCreate *MarketPriceRepositoryMock) BulkCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBulkCreate.beforeBulkCreateCounter)
}

// Calls returns a list of arguments used in each call to MarketPriceRepositoryMock.BulkCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBulkCreate *mMarketPriceRepositoryMockBulkCreate) Calls() []*MarketPriceRepositoryMockBulkCreateParams {
	mmBulkCreate.mutex.RLock()

	argCopy := make([]*MarketPriceRepositoryMockBulkCreateParams, len(mmBulkCreate.callArgs))
	copy(argCopy, mmBulkCreate.callArgs)

	mmBulkCreate.mutex.RUnlock()

	return argCopy
}

// MinimockBulkCreateDone returns true if the count of the BulkCreate invocations corresponds
// the number of defined expectations
func (m *MarketPriceRepositoryMock) MinimockBulkCreateDone() bool {
	for _, e := range m.BulkCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BulkCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBulkCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBulkCreate != nil && mm_atomic.LoadUint64(&m.afterBulkCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockBulkCreateInspect logs each unmet expectation
func (m *MarketPriceRepositoryMock) MinimockBulkCreateInspect() {
	for _, e := range m.BulkCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.BulkCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BulkCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBulkCreateCounter) < 1 {
		if m.BulkCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MarketPriceRepositoryMock.BulkCreate")
		} else {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.BulkCreate with params: %#v", *m.BulkCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBulkCreate != nil && mm_atomic.LoadUint64(&m.afterBulkCreateCounter) < 1 {
		m.t.Error("Expected call to MarketPriceRepositoryMock.BulkCreate")
	}
}

type mMarketPriceRepositoryMockCreate struct {
	mock               *MarketPriceRepositoryMock
	defaultExpectation *MarketPriceRepositoryMockCreateExpectation
	expectations       []*MarketPriceRepositoryMockCreateExpectation

	callArgs []*MarketPriceRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// MarketPriceRepositoryMockCreateExpectation specifies expectation struct of the MarketPriceRepository.Create
type MarketPriceRepositoryMockCreateExpectation struct {
	mock    *MarketPriceRepositoryMock
	params  *MarketPriceRepositoryMockCreateParams
	results *MarketPriceRepositoryMockCreateResults
	Counter uint64
}

// MarketPriceRepositoryMockCreateParams contains parameters of the MarketPriceRepository.Create
type MarketPriceRepositoryMockCreateParams struct {
	ctx         context.Context
	marketPrice *domain.MarketPrice
}

// MarketPriceRepositoryMockCreateResults contains results of the MarketPriceRepository.Create
type MarketPriceRepositoryMockCreateResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for MarketPriceRepository.Create
func (mmCreate *mMarketPriceRepositoryMockCreate) Expect(ctx context.Context, marketPrice *domain.MarketPrice) *mMarketPriceRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MarketPriceRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MarketPriceRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &MarketPriceRepositoryMockCreateParams{ctx, marketPrice}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the MarketPriceRepository.Create
func (mmCreate *mMarketPriceRepositoryMockCreate) Inspect(f func(ctx context.Context, marketPrice *domain.MarketPrice)) *mMarketPriceRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for MarketPriceRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by MarketPriceRepository.Create
func (mmCreate *mMarketPriceRepositoryMockCreate) Return(b1 bool, err error) *MarketPriceRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MarketPriceRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MarketPriceRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &MarketPriceRepositoryMockCreateResults{b1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the MarketPriceRepository.Create method
func (mmCreate *mMarketPriceRepositoryMockCreate) Set(f func(ctx context.Context, marketPrice *domain.MarketPrice) (b1 bool, err error)) *MarketPriceRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the MarketPriceRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the MarketPriceRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the MarketPriceRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mMarketPriceRepositoryMockCreate) When(ctx context.Context, marketPrice *domain.MarketPrice) *MarketPriceRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MarketPriceRepositoryMock.Create mock is already set by Set")
	}

	expectation := &MarketPriceRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &MarketPriceRepositoryMockCreateParams{ctx, marketPrice},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up MarketPriceRepository.Create return parameters for the expectation previously defined by the When method
func (e *MarketPriceRepositoryMockCreateExpectation) Then(b1 bool, err error) *MarketPriceRepositoryMock {
	e.results = &MarketPriceRepositoryMockCreateResults{b1, err}
	return e.mock
}

// Create implements MarketPriceRepository
func (mmCreate *MarketPriceRepositoryMock) Create(ctx context.Context, marketPrice *domain.MarketPrice) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, marketPrice)
	}

	mm_params := &MarketPriceRepositoryMockCreateParams{ctx, marketPrice}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := MarketPriceRepositoryMockCreateParams{ctx, marketPrice}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("MarketPriceRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the MarketPriceRepositoryMock.Create")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, marketPrice)
	}
	mmCreate.t.Fatalf("Unexpected call to MarketPriceRepositoryMock.Create. %v %v", ctx, marketPrice)
	return
}

// CreateAfterCounter returns a count of finished MarketPriceRepositoryMock.Create invocations
func (mmCreate *MarketPriceRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of MarketPriceRepositoryMock.Create invocations
func (mmCreate *MarketPriceRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to MarketPriceRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mMarketPriceRepositoryMockCreate) Calls() []*MarketPriceRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*MarketPriceRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *MarketPriceRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *MarketPriceRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MarketPriceRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to MarketPriceRepositoryMock.Create")
	}
}

type mMarketPriceRepositoryMockRetrieveInterval struct {
	mock               *MarketPriceRepositoryMock
	defaultExpectation *MarketPriceRepositoryMockRetrieveIntervalExpectation
	expectations       []*MarketPriceRepositoryMockRetrieveIntervalExpectation

	callArgs []*MarketPriceRepositoryMockRetrieveIntervalParams
	mutex    sync.RWMutex
}

// MarketPriceRepositoryMockRetrieveIntervalExpectation specifies expectation struct of the MarketPriceRepository.RetrieveInterval
type MarketPriceRepositoryMockRetrieveIntervalExpectation struct {
	mock    *MarketPriceRepositoryMock
	params  *MarketPriceRepositoryMockRetrieveIntervalParams
	results *MarketPriceRepositoryMockRetrieveIntervalResults
	Counter uint64
}

// MarketPriceRepositoryMockRetrieveIntervalParams contains parameters of the MarketPriceRepository.RetrieveInterval
type MarketPriceRepositoryMockRetrieveIntervalParams struct {
	ctx          context.Context
	marketItemId int64
	start        int64
	end          int64
}

// MarketPriceRepositoryMockRetrieveIntervalResults contains results of the MarketPriceRepository.RetrieveInterval
type MarketPriceRepositoryMockRetrieveIntervalResults struct {
	mp1 *domain.MarketPricesRetrieve
}

// Expect sets up expected params for MarketPriceRepository.RetrieveInterval
func (mmRetrieveInterval *mMarketPriceRepositoryMockRetrieveInterval) Expect(ctx context.Context, marketItemId int64, start int64, end int64) *mMarketPriceRepositoryMockRetrieveInterval {
	if mmRetrieveInterval.mock.funcRetrieveInterval != nil {
		mmRetrieveInterval.mock.t.Fatalf("MarketPriceRepositoryMock.RetrieveInterval mock is already set by Set")
	}

	if mmRetrieveInterval.defaultExpectation == nil {
		mmRetrieveInterval.defaultExpectation = &MarketPriceRepositoryMockRetrieveIntervalExpectation{}
	}

	mmRetrieveInterval.defaultExpectation.params = &MarketPriceRepositoryMockRetrieveIntervalParams{ctx, marketItemId, start, end}
	for _, e := range mmRetrieveInterval.expectations {
		if minimock.Equal(e.params, mmRetrieveInterval.defaultExpectation.params) {
			mmRetrieveInterval.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrieveInterval.defaultExpectation.params)
		}
	}

	return mmRetrieveInterval
}

// Inspect accepts an inspector function that has same arguments as the MarketPriceRepository.RetrieveInterval
func (mmRetrieveInterval *mMarketPriceRepositoryMockRetrieveInterval) Inspect(f func(ctx context.Context, marketItemId int64, start int64, end int64)) *mMarketPriceRepositoryMockRetrieveInterval {
	if mmRetrieveInterval.mock.inspectFuncRetrieveInterval != nil {
		mmRetrieveInterval.mock.t.Fatalf("Inspect function is already set for MarketPriceRepositoryMock.RetrieveInterval")
	}

	mmRetrieveInterval.mock.inspectFuncRetrieveInterval = f

	return mmRetrieveInterval
}

// Return sets up results that will be returned by MarketPriceRepository.RetrieveInterval
func (mmRetrieveInterval *mMarketPriceRepositoryMockRetrieveInterval) Return(mp1 *domain.MarketPricesRetrieve) *MarketPriceRepositoryMock {
	if mmRetrieveInterval.mock.funcRetrieveInterval != nil {
		mmRetrieveInterval.mock.t.Fatalf("MarketPriceRepositoryMock.RetrieveInterval mock is already set by Set")
	}

	if mmRetrieveInterval.defaultExpectation == nil {
		mmRetrieveInterval.defaultExpectation = &MarketPriceRepositoryMockRetrieveIntervalExpectation{mock: mmRetrieveInterval.mock}
	}
	mmRetrieveInterval.defaultExpectation.results = &MarketPriceRepositoryMockRetrieveIntervalResults{mp1}
	return mmRetrieveInterval.mock
}

//Set uses given function f to mock the MarketPriceRepository.RetrieveInterval method
func (mmRetrieveInterval *mMarketPriceRepositoryMockRetrieveInterval) Set(f func(ctx context.Context, marketItemId int64, start int64, end int64) (mp1 *domain.MarketPricesRetrieve)) *MarketPriceRepositoryMock {
	if mmRetrieveInterval.defaultExpectation != nil {
		mmRetrieveInterval.mock.t.Fatalf("Default expectation is already set for the MarketPriceRepository.RetrieveInterval method")
	}

	if len(mmRetrieveInterval.expectations) > 0 {
		mmRetrieveInterval.mock.t.Fatalf("Some expectations are already set for the MarketPriceRepository.RetrieveInterval method")
	}

	mmRetrieveInterval.mock.funcRetrieveInterval = f
	return mmRetrieveInterval.mock
}

// When sets expectation for the MarketPriceRepository.RetrieveInterval which will trigger the result defined by the following
// Then helper
func (mmRetrieveInterval *mMarketPriceRepositoryMockRetrieveInterval) When(ctx context.Context, marketItemId int64, start int64, end int64) *MarketPriceRepositoryMockRetrieveIntervalExpectation {
	if mmRetrieveInterval.mock.funcRetrieveInterval != nil {
		mmRetrieveInterval.mock.t.Fatalf("MarketPriceRepositoryMock.RetrieveInterval mock is already set by Set")
	}

	expectation := &MarketPriceRepositoryMockRetrieveIntervalExpectation{
		mock:   mmRetrieveInterval.mock,
		params: &MarketPriceRepositoryMockRetrieveIntervalParams{ctx, marketItemId, start, end},
	}
	mmRetrieveInterval.expectations = append(mmRetrieveInterval.expectations, expectation)
	return expectation
}

// Then sets up MarketPriceRepository.RetrieveInterval return parameters for the expectation previously defined by the When method
func (e *MarketPriceRepositoryMockRetrieveIntervalExpectation) Then(mp1 *domain.MarketPricesRetrieve) *MarketPriceRepositoryMock {
	e.results = &MarketPriceRepositoryMockRetrieveIntervalResults{mp1}
	return e.mock
}

// RetrieveInterval implements MarketPriceRepository
func (mmRetrieveInterval *MarketPriceRepositoryMock) RetrieveInterval(ctx context.Context, marketItemId int64, start int64, end int64) (mp1 *domain.MarketPricesRetrieve) {
	mm_atomic.AddUint64(&mmRetrieveInterval.beforeRetrieveIntervalCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrieveInterval.afterRetrieveIntervalCounter, 1)

	if mmRetrieveInterval.inspectFuncRetrieveInterval != nil {
		mmRetrieveInterval.inspectFuncRetrieveInterval(ctx, marketItemId, start, end)
	}

	mm_params := &MarketPriceRepositoryMockRetrieveIntervalParams{ctx, marketItemId, start, end}

	// Record call args
	mmRetrieveInterval.RetrieveIntervalMock.mutex.Lock()
	mmRetrieveInterval.RetrieveIntervalMock.callArgs = append(mmRetrieveInterval.RetrieveIntervalMock.callArgs, mm_params)
	mmRetrieveInterval.RetrieveIntervalMock.mutex.Unlock()

	for _, e := range mmRetrieveInterval.RetrieveIntervalMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1
		}
	}

	if mmRetrieveInterval.RetrieveIntervalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrieveInterval.RetrieveIntervalMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrieveInterval.RetrieveIntervalMock.defaultExpectation.params
		mm_got := MarketPriceRepositoryMockRetrieveIntervalParams{ctx, marketItemId, start, end}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrieveInterval.t.Errorf("MarketPriceRepositoryMock.RetrieveInterval got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrieveInterval.RetrieveIntervalMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrieveInterval.t.Fatal("No results are set for the MarketPriceRepositoryMock.RetrieveInterval")
		}
		return (*mm_results).mp1
	}
	if mmRetrieveInterval.funcRetrieveInterval != nil {
		return mmRetrieveInterval.funcRetrieveInterval(ctx, marketItemId, start, end)
	}
	mmRetrieveInterval.t.Fatalf("Unexpected call to MarketPriceRepositoryMock.RetrieveInterval. %v %v %v %v", ctx, marketItemId, start, end)
	return
}

// RetrieveIntervalAfterCounter returns a count of finished MarketPriceRepositoryMock.RetrieveInterval invocations
func (mmRetrieveInterval *MarketPriceRepositoryMock) RetrieveIntervalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveInterval.afterRetrieveIntervalCounter)
}

// RetrieveIntervalBeforeCounter returns a count of MarketPriceRepositoryMock.RetrieveInterval invocations
func (mmRetrieveInterval *MarketPriceRepositoryMock) RetrieveIntervalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveInterval.beforeRetrieveIntervalCounter)
}

// Calls returns a list of arguments used in each call to MarketPriceRepositoryMock.RetrieveInterval.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrieveInterval *mMarketPriceRepositoryMockRetrieveInterval) Calls() []*MarketPriceRepositoryMockRetrieveIntervalParams {
	mmRetrieveInterval.mutex.RLock()

	argCopy := make([]*MarketPriceRepositoryMockRetrieveIntervalParams, len(mmRetrieveInterval.callArgs))
	copy(argCopy, mmRetrieveInterval.callArgs)

	mmRetrieveInterval.mutex.RUnlock()

	return argCopy
}

// MinimockRetrieveIntervalDone returns true if the count of the RetrieveInterval invocations corresponds
// the number of defined expectations
func (m *MarketPriceRepositoryMock) MinimockRetrieveIntervalDone() bool {
	for _, e := range m.RetrieveIntervalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveIntervalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveIntervalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveInterval != nil && mm_atomic.LoadUint64(&m.afterRetrieveIntervalCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrieveIntervalInspect logs each unmet expectation
func (m *MarketPriceRepositoryMock) MinimockRetrieveIntervalInspect() {
	for _, e := range m.RetrieveIntervalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.RetrieveInterval with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveIntervalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveIntervalCounter) < 1 {
		if m.RetrieveIntervalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MarketPriceRepositoryMock.RetrieveInterval")
		} else {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.RetrieveInterval with params: %#v", *m.RetrieveIntervalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveInterval != nil && mm_atomic.LoadUint64(&m.afterRetrieveIntervalCounter) < 1 {
		m.t.Error("Expected call to MarketPriceRepositoryMock.RetrieveInterval")
	}
}

type mMarketPriceRepositoryMockRetrieveLast struct {
	mock               *MarketPriceRepositoryMock
	defaultExpectation *MarketPriceRepositoryMockRetrieveLastExpectation
	expectations       []*MarketPriceRepositoryMockRetrieveLastExpectation

	callArgs []*MarketPriceRepositoryMockRetrieveLastParams
	mutex    sync.RWMutex
}

// MarketPriceRepositoryMockRetrieveLastExpectation specifies expectation struct of the MarketPriceRepository.RetrieveLast
type MarketPriceRepositoryMockRetrieveLastExpectation struct {
	mock    *MarketPriceRepositoryMock
	params  *MarketPriceRepositoryMockRetrieveLastParams
	results *MarketPriceRepositoryMockRetrieveLastResults
	Counter uint64
}

// MarketPriceRepositoryMockRetrieveLastParams contains parameters of the MarketPriceRepository.RetrieveLast
type MarketPriceRepositoryMockRetrieveLastParams struct {
	ctx          context.Context
	marketItemId int64
}

// MarketPriceRepositoryMockRetrieveLastResults contains results of the MarketPriceRepository.RetrieveLast
type MarketPriceRepositoryMockRetrieveLastResults struct {
	m1 domain.MarketPriceRetrieve
}

// Expect sets up expected params for MarketPriceRepository.RetrieveLast
func (mmRetrieveLast *mMarketPriceRepositoryMockRetrieveLast) Expect(ctx context.Context, marketItemId int64) *mMarketPriceRepositoryMockRetrieveLast {
	if mmRetrieveLast.mock.funcRetrieveLast != nil {
		mmRetrieveLast.mock.t.Fatalf("MarketPriceRepositoryMock.RetrieveLast mock is already set by Set")
	}

	if mmRetrieveLast.defaultExpectation == nil {
		mmRetrieveLast.defaultExpectation = &MarketPriceRepositoryMockRetrieveLastExpectation{}
	}

	mmRetrieveLast.defaultExpectation.params = &MarketPriceRepositoryMockRetrieveLastParams{ctx, marketItemId}
	for _, e := range mmRetrieveLast.expectations {
		if minimock.Equal(e.params, mmRetrieveLast.defaultExpectation.params) {
			mmRetrieveLast.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrieveLast.defaultExpectation.params)
		}
	}

	return mmRetrieveLast
}

// Inspect accepts an inspector function that has same arguments as the MarketPriceRepository.RetrieveLast
func (mmRetrieveLast *mMarketPriceRepositoryMockRetrieveLast) Inspect(f func(ctx context.Context, marketItemId int64)) *mMarketPriceRepositoryMockRetrieveLast {
	if mmRetrieveLast.mock.inspectFuncRetrieveLast != nil {
		mmRetrieveLast.mock.t.Fatalf("Inspect function is already set for MarketPriceRepositoryMock.RetrieveLast")
	}

	mmRetrieveLast.mock.inspectFuncRetrieveLast = f

	return mmRetrieveLast
}

// Return sets up results that will be returned by MarketPriceRepository.RetrieveLast
func (mmRetrieveLast *mMarketPriceRepositoryMockRetrieveLast) Return(m1 domain.MarketPriceRetrieve) *MarketPriceRepositoryMock {
	if mmRetrieveLast.mock.funcRetrieveLast != nil {
		mmRetrieveLast.mock.t.Fatalf("MarketPriceRepositoryMock.RetrieveLast mock is already set by Set")
	}

	if mmRetrieveLast.defaultExpectation == nil {
		mmRetrieveLast.defaultExpectation = &MarketPriceRepositoryMockRetrieveLastExpectation{mock: mmRetrieveLast.mock}
	}
	mmRetrieveLast.defaultExpectation.results = &MarketPriceRepositoryMockRetrieveLastResults{m1}
	return mmRetrieveLast.mock
}

//Set uses given function f to mock the MarketPriceRepository.RetrieveLast method
func (mmRetrieveLast *mMarketPriceRepositoryMockRetrieveLast) Set(f func(ctx context.Context, marketItemId int64) (m1 domain.MarketPriceRetrieve)) *MarketPriceRepositoryMock {
	if mmRetrieveLast.defaultExpectation != nil {
		mmRetrieveLast.mock.t.Fatalf("Default expectation is already set for the MarketPriceRepository.RetrieveLast method")
	}

	if len(mmRetrieveLast.expectations) > 0 {
		mmRetrieveLast.mock.t.Fatalf("Some expectations are already set for the MarketPriceRepository.RetrieveLast method")
	}

	mmRetrieveLast.mock.funcRetrieveLast = f
	return mmRetrieveLast.mock
}

// When sets expectation for the MarketPriceRepository.RetrieveLast which will trigger the result defined by the following
// Then helper
func (mmRetrieveLast *mMarketPriceRepositoryMockRetrieveLast) When(ctx context.Context, marketItemId int64) *MarketPriceRepositoryMockRetrieveLastExpectation {
	if mmRetrieveLast.mock.funcRetrieveLast != nil {
		mmRetrieveLast.mock.t.Fatalf("MarketPriceRepositoryMock.RetrieveLast mock is already set by Set")
	}

	expectation := &MarketPriceRepositoryMockRetrieveLastExpectation{
		mock:   mmRetrieveLast.mock,
		params: &MarketPriceRepositoryMockRetrieveLastParams{ctx, marketItemId},
	}
	mmRetrieveLast.expectations = append(mmRetrieveLast.expectations, expectation)
	return expectation
}

// Then sets up MarketPriceRepository.RetrieveLast return parameters for the expectation previously defined by the When method
func (e *MarketPriceRepositoryMockRetrieveLastExpectation) Then(m1 domain.MarketPriceRetrieve) *MarketPriceRepositoryMock {
	e.results = &MarketPriceRepositoryMockRetrieveLastResults{m1}
	return e.mock
}

// RetrieveLast implements MarketPriceRepository
func (mmRetrieveLast *MarketPriceRepositoryMock) RetrieveLast(ctx context.Context, marketItemId int64) (m1 domain.MarketPriceRetrieve) {
	mm_atomic.AddUint64(&mmRetrieveLast.beforeRetrieveLastCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrieveLast.afterRetrieveLastCounter, 1)

	if mmRetrieveLast.inspectFuncRetrieveLast != nil {
		mmRetrieveLast.inspectFuncRetrieveLast(ctx, marketItemId)
	}

	mm_params := &MarketPriceRepositoryMockRetrieveLastParams{ctx, marketItemId}

	// Record call args
	mmRetrieveLast.RetrieveLastMock.mutex.Lock()
	mmRetrieveLast.RetrieveLastMock.callArgs = append(mmRetrieveLast.RetrieveLastMock.callArgs, mm_params)
	mmRetrieveLast.RetrieveLastMock.mutex.Unlock()

	for _, e := range mmRetrieveLast.RetrieveLastMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1
		}
	}

	if mmRetrieveLast.RetrieveLastMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrieveLast.RetrieveLastMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrieveLast.RetrieveLastMock.defaultExpectation.params
		mm_got := MarketPriceRepositoryMockRetrieveLastParams{ctx, marketItemId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrieveLast.t.Errorf("MarketPriceRepositoryMock.RetrieveLast got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrieveLast.RetrieveLastMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrieveLast.t.Fatal("No results are set for the MarketPriceRepositoryMock.RetrieveLast")
		}
		return (*mm_results).m1
	}
	if mmRetrieveLast.funcRetrieveLast != nil {
		return mmRetrieveLast.funcRetrieveLast(ctx, marketItemId)
	}
	mmRetrieveLast.t.Fatalf("Unexpected call to MarketPriceRepositoryMock.RetrieveLast. %v %v", ctx, marketItemId)
	return
}

// RetrieveLastAfterCounter returns a count of finished MarketPriceRepositoryMock.RetrieveLast invocations
func (mmRetrieveLast *MarketPriceRepositoryMock) RetrieveLastAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveLast.afterRetrieveLastCounter)
}

// RetrieveLastBeforeCounter returns a count of MarketPriceRepositoryMock.RetrieveLast invocations
func (mmRetrieveLast *MarketPriceRepositoryMock) RetrieveLastBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveLast.beforeRetrieveLastCounter)
}

// Calls returns a list of arguments used in each call to MarketPriceRepositoryMock.RetrieveLast.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrieveLast *mMarketPriceRepositoryMockRetrieveLast) Calls() []*MarketPriceRepositoryMockRetrieveLastParams {
	mmRetrieveLast.mutex.RLock()

	argCopy := make([]*MarketPriceRepositoryMockRetrieveLastParams, len(mmRetrieveLast.callArgs))
	copy(argCopy, mmRetrieveLast.callArgs)

	mmRetrieveLast.mutex.RUnlock()

	return argCopy
}

// MinimockRetrieveLastDone returns true if the count of the RetrieveLast invocations corresponds
// the number of defined expectations
func (m *MarketPriceRepositoryMock) MinimockRetrieveLastDone() bool {
	for _, e := range m.RetrieveLastMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveLastMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveLastCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveLast != nil && mm_atomic.LoadUint64(&m.afterRetrieveLastCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrieveLastInspect logs each unmet expectation
func (m *MarketPriceRepositoryMock) MinimockRetrieveLastInspect() {
	for _, e := range m.RetrieveLastMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.RetrieveLast with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveLastMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveLastCounter) < 1 {
		if m.RetrieveLastMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MarketPriceRepositoryMock.RetrieveLast")
		} else {
			m.t.Errorf("Expected call to MarketPriceRepositoryMock.RetrieveLast with params: %#v", *m.RetrieveLastMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveLast != nil && mm_atomic.LoadUint64(&m.afterRetrieveLastCounter) < 1 {
		m.t.Error("Expected call to MarketPriceRepositoryMock.RetrieveLast")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MarketPriceRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBulkCreateInspect()

		m.MinimockCreateInspect()

		m.MinimockRetrieveIntervalInspect()

		m.MinimockRetrieveLastInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MarketPriceRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MarketPriceRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBulkCreateDone() &&
		m.MinimockCreateDone() &&
		m.MinimockRetrieveIntervalDone() &&
		m.MinimockRetrieveLastDone()
}
