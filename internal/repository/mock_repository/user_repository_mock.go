package mock_repository

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/abrbird/portfolio_bot/internal/repository.UserRepository -o ./user_repository_mock_test.go -n UserRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/abrbird/portfolio_bot/internal/domain"
)

// UserRepositoryMock implements UserRepository
type UserRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, user *domain.User) (err error)
	inspectFuncCreate   func(ctx context.Context, user *domain.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserRepositoryMockCreate

	funcDelete          func(ctx context.Context, userId domain.UserId) (err error)
	inspectFuncDelete   func(ctx context.Context, userId domain.UserId)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserRepositoryMockDelete

	funcRetrieve          func(ctx context.Context, userId domain.UserId) (u1 domain.UserRetrieve)
	inspectFuncRetrieve   func(ctx context.Context, userId domain.UserId)
	afterRetrieveCounter  uint64
	beforeRetrieveCounter uint64
	RetrieveMock          mUserRepositoryMockRetrieve

	funcRetrieveOrCreate          func(ctx context.Context, user *domain.User) (u1 domain.UserRetrieve)
	inspectFuncRetrieveOrCreate   func(ctx context.Context, user *domain.User)
	afterRetrieveOrCreateCounter  uint64
	beforeRetrieveOrCreateCounter uint64
	RetrieveOrCreateMock          mUserRepositoryMockRetrieveOrCreate

	funcUpdate          func(ctx context.Context, user *domain.User) (err error)
	inspectFuncUpdate   func(ctx context.Context, user *domain.User)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserRepositoryMockUpdate
}

// NewUserRepositoryMock returns a mock for UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

	m.DeleteMock = mUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

	m.RetrieveMock = mUserRepositoryMockRetrieve{mock: m}
	m.RetrieveMock.callArgs = []*UserRepositoryMockRetrieveParams{}

	m.RetrieveOrCreateMock = mUserRepositoryMockRetrieveOrCreate{mock: m}
	m.RetrieveOrCreateMock.callArgs = []*UserRepositoryMockRetrieveOrCreateParams{}

	m.UpdateMock = mUserRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserRepositoryMockUpdateParams{}

	return m
}

type mUserRepositoryMockCreate struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateExpectation
	expectations       []*UserRepositoryMockCreateExpectation

	callArgs []*UserRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockCreateParams
	results *UserRepositoryMockCreateResults
	Counter uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
	ctx  context.Context
	user *domain.User
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, user *domain.User) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &UserRepositoryMockCreateParams{ctx, user}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, user *domain.User)) *mUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(err error) *UserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserRepositoryMockCreateResults{err}
	return mmCreate.mock
}

//Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, user *domain.User) (err error)) *UserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, user *domain.User) *UserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &UserRepositoryMockCreateParams{ctx, user},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, user *domain.User) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, user)
	}

	mm_params := &UserRepositoryMockCreateParams{ctx, user}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := UserRepositoryMockCreateParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, user)
	}
	mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v", ctx, user)
	return
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Create")
	}
}

type mUserRepositoryMockDelete struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteExpectation
	expectations       []*UserRepositoryMockDeleteExpectation

	callArgs []*UserRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockDeleteParams
	results *UserRepositoryMockDeleteResults
	Counter uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
	ctx    context.Context
	userId domain.UserId
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, userId domain.UserId) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &UserRepositoryMockDeleteParams{ctx, userId}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, userId domain.UserId)) *mUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, userId domain.UserId) (err error)) *UserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, userId domain.UserId) *UserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UserRepositoryMockDeleteParams{ctx, userId},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, userId domain.UserId) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, userId)
	}

	mm_params := &UserRepositoryMockDeleteParams{ctx, userId}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := UserRepositoryMockDeleteParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, userId)
	}
	mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, userId)
	return
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Delete")
	}
}

type mUserRepositoryMockRetrieve struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockRetrieveExpectation
	expectations       []*UserRepositoryMockRetrieveExpectation

	callArgs []*UserRepositoryMockRetrieveParams
	mutex    sync.RWMutex
}

// UserRepositoryMockRetrieveExpectation specifies expectation struct of the UserRepository.Retrieve
type UserRepositoryMockRetrieveExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockRetrieveParams
	results *UserRepositoryMockRetrieveResults
	Counter uint64
}

// UserRepositoryMockRetrieveParams contains parameters of the UserRepository.Retrieve
type UserRepositoryMockRetrieveParams struct {
	ctx    context.Context
	userId domain.UserId
}

// UserRepositoryMockRetrieveResults contains results of the UserRepository.Retrieve
type UserRepositoryMockRetrieveResults struct {
	u1 domain.UserRetrieve
}

// Expect sets up expected params for UserRepository.Retrieve
func (mmRetrieve *mUserRepositoryMockRetrieve) Expect(ctx context.Context, userId domain.UserId) *mUserRepositoryMockRetrieve {
	if mmRetrieve.mock.funcRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("UserRepositoryMock.Retrieve mock is already set by Set")
	}

	if mmRetrieve.defaultExpectation == nil {
		mmRetrieve.defaultExpectation = &UserRepositoryMockRetrieveExpectation{}
	}

	mmRetrieve.defaultExpectation.params = &UserRepositoryMockRetrieveParams{ctx, userId}
	for _, e := range mmRetrieve.expectations {
		if minimock.Equal(e.params, mmRetrieve.defaultExpectation.params) {
			mmRetrieve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrieve.defaultExpectation.params)
		}
	}

	return mmRetrieve
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Retrieve
func (mmRetrieve *mUserRepositoryMockRetrieve) Inspect(f func(ctx context.Context, userId domain.UserId)) *mUserRepositoryMockRetrieve {
	if mmRetrieve.mock.inspectFuncRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Retrieve")
	}

	mmRetrieve.mock.inspectFuncRetrieve = f

	return mmRetrieve
}

// Return sets up results that will be returned by UserRepository.Retrieve
func (mmRetrieve *mUserRepositoryMockRetrieve) Return(u1 domain.UserRetrieve) *UserRepositoryMock {
	if mmRetrieve.mock.funcRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("UserRepositoryMock.Retrieve mock is already set by Set")
	}

	if mmRetrieve.defaultExpectation == nil {
		mmRetrieve.defaultExpectation = &UserRepositoryMockRetrieveExpectation{mock: mmRetrieve.mock}
	}
	mmRetrieve.defaultExpectation.results = &UserRepositoryMockRetrieveResults{u1}
	return mmRetrieve.mock
}

//Set uses given function f to mock the UserRepository.Retrieve method
func (mmRetrieve *mUserRepositoryMockRetrieve) Set(f func(ctx context.Context, userId domain.UserId) (u1 domain.UserRetrieve)) *UserRepositoryMock {
	if mmRetrieve.defaultExpectation != nil {
		mmRetrieve.mock.t.Fatalf("Default expectation is already set for the UserRepository.Retrieve method")
	}

	if len(mmRetrieve.expectations) > 0 {
		mmRetrieve.mock.t.Fatalf("Some expectations are already set for the UserRepository.Retrieve method")
	}

	mmRetrieve.mock.funcRetrieve = f
	return mmRetrieve.mock
}

// When sets expectation for the UserRepository.Retrieve which will trigger the result defined by the following
// Then helper
func (mmRetrieve *mUserRepositoryMockRetrieve) When(ctx context.Context, userId domain.UserId) *UserRepositoryMockRetrieveExpectation {
	if mmRetrieve.mock.funcRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("UserRepositoryMock.Retrieve mock is already set by Set")
	}

	expectation := &UserRepositoryMockRetrieveExpectation{
		mock:   mmRetrieve.mock,
		params: &UserRepositoryMockRetrieveParams{ctx, userId},
	}
	mmRetrieve.expectations = append(mmRetrieve.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Retrieve return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockRetrieveExpectation) Then(u1 domain.UserRetrieve) *UserRepositoryMock {
	e.results = &UserRepositoryMockRetrieveResults{u1}
	return e.mock
}

// Retrieve implements UserRepository
func (mmRetrieve *UserRepositoryMock) Retrieve(ctx context.Context, userId domain.UserId) (u1 domain.UserRetrieve) {
	mm_atomic.AddUint64(&mmRetrieve.beforeRetrieveCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrieve.afterRetrieveCounter, 1)

	if mmRetrieve.inspectFuncRetrieve != nil {
		mmRetrieve.inspectFuncRetrieve(ctx, userId)
	}

	mm_params := &UserRepositoryMockRetrieveParams{ctx, userId}

	// Record call args
	mmRetrieve.RetrieveMock.mutex.Lock()
	mmRetrieve.RetrieveMock.callArgs = append(mmRetrieve.RetrieveMock.callArgs, mm_params)
	mmRetrieve.RetrieveMock.mutex.Unlock()

	for _, e := range mmRetrieve.RetrieveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1
		}
	}

	if mmRetrieve.RetrieveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrieve.RetrieveMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrieve.RetrieveMock.defaultExpectation.params
		mm_got := UserRepositoryMockRetrieveParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrieve.t.Errorf("UserRepositoryMock.Retrieve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrieve.RetrieveMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrieve.t.Fatal("No results are set for the UserRepositoryMock.Retrieve")
		}
		return (*mm_results).u1
	}
	if mmRetrieve.funcRetrieve != nil {
		return mmRetrieve.funcRetrieve(ctx, userId)
	}
	mmRetrieve.t.Fatalf("Unexpected call to UserRepositoryMock.Retrieve. %v %v", ctx, userId)
	return
}

// RetrieveAfterCounter returns a count of finished UserRepositoryMock.Retrieve invocations
func (mmRetrieve *UserRepositoryMock) RetrieveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieve.afterRetrieveCounter)
}

// RetrieveBeforeCounter returns a count of UserRepositoryMock.Retrieve invocations
func (mmRetrieve *UserRepositoryMock) RetrieveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieve.beforeRetrieveCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Retrieve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrieve *mUserRepositoryMockRetrieve) Calls() []*UserRepositoryMockRetrieveParams {
	mmRetrieve.mutex.RLock()

	argCopy := make([]*UserRepositoryMockRetrieveParams, len(mmRetrieve.callArgs))
	copy(argCopy, mmRetrieve.callArgs)

	mmRetrieve.mutex.RUnlock()

	return argCopy
}

// MinimockRetrieveDone returns true if the count of the Retrieve invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockRetrieveDone() bool {
	for _, e := range m.RetrieveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieve != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrieveInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockRetrieveInspect() {
	for _, e := range m.RetrieveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Retrieve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		if m.RetrieveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Retrieve")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Retrieve with params: %#v", *m.RetrieveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieve != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Retrieve")
	}
}

type mUserRepositoryMockRetrieveOrCreate struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockRetrieveOrCreateExpectation
	expectations       []*UserRepositoryMockRetrieveOrCreateExpectation

	callArgs []*UserRepositoryMockRetrieveOrCreateParams
	mutex    sync.RWMutex
}

// UserRepositoryMockRetrieveOrCreateExpectation specifies expectation struct of the UserRepository.RetrieveOrCreate
type UserRepositoryMockRetrieveOrCreateExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockRetrieveOrCreateParams
	results *UserRepositoryMockRetrieveOrCreateResults
	Counter uint64
}

// UserRepositoryMockRetrieveOrCreateParams contains parameters of the UserRepository.RetrieveOrCreate
type UserRepositoryMockRetrieveOrCreateParams struct {
	ctx  context.Context
	user *domain.User
}

// UserRepositoryMockRetrieveOrCreateResults contains results of the UserRepository.RetrieveOrCreate
type UserRepositoryMockRetrieveOrCreateResults struct {
	u1 domain.UserRetrieve
}

// Expect sets up expected params for UserRepository.RetrieveOrCreate
func (mmRetrieveOrCreate *mUserRepositoryMockRetrieveOrCreate) Expect(ctx context.Context, user *domain.User) *mUserRepositoryMockRetrieveOrCreate {
	if mmRetrieveOrCreate.mock.funcRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("UserRepositoryMock.RetrieveOrCreate mock is already set by Set")
	}

	if mmRetrieveOrCreate.defaultExpectation == nil {
		mmRetrieveOrCreate.defaultExpectation = &UserRepositoryMockRetrieveOrCreateExpectation{}
	}

	mmRetrieveOrCreate.defaultExpectation.params = &UserRepositoryMockRetrieveOrCreateParams{ctx, user}
	for _, e := range mmRetrieveOrCreate.expectations {
		if minimock.Equal(e.params, mmRetrieveOrCreate.defaultExpectation.params) {
			mmRetrieveOrCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrieveOrCreate.defaultExpectation.params)
		}
	}

	return mmRetrieveOrCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.RetrieveOrCreate
func (mmRetrieveOrCreate *mUserRepositoryMockRetrieveOrCreate) Inspect(f func(ctx context.Context, user *domain.User)) *mUserRepositoryMockRetrieveOrCreate {
	if mmRetrieveOrCreate.mock.inspectFuncRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.RetrieveOrCreate")
	}

	mmRetrieveOrCreate.mock.inspectFuncRetrieveOrCreate = f

	return mmRetrieveOrCreate
}

// Return sets up results that will be returned by UserRepository.RetrieveOrCreate
func (mmRetrieveOrCreate *mUserRepositoryMockRetrieveOrCreate) Return(u1 domain.UserRetrieve) *UserRepositoryMock {
	if mmRetrieveOrCreate.mock.funcRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("UserRepositoryMock.RetrieveOrCreate mock is already set by Set")
	}

	if mmRetrieveOrCreate.defaultExpectation == nil {
		mmRetrieveOrCreate.defaultExpectation = &UserRepositoryMockRetrieveOrCreateExpectation{mock: mmRetrieveOrCreate.mock}
	}
	mmRetrieveOrCreate.defaultExpectation.results = &UserRepositoryMockRetrieveOrCreateResults{u1}
	return mmRetrieveOrCreate.mock
}

//Set uses given function f to mock the UserRepository.RetrieveOrCreate method
func (mmRetrieveOrCreate *mUserRepositoryMockRetrieveOrCreate) Set(f func(ctx context.Context, user *domain.User) (u1 domain.UserRetrieve)) *UserRepositoryMock {
	if mmRetrieveOrCreate.defaultExpectation != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.RetrieveOrCreate method")
	}

	if len(mmRetrieveOrCreate.expectations) > 0 {
		mmRetrieveOrCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.RetrieveOrCreate method")
	}

	mmRetrieveOrCreate.mock.funcRetrieveOrCreate = f
	return mmRetrieveOrCreate.mock
}

// When sets expectation for the UserRepository.RetrieveOrCreate which will trigger the result defined by the following
// Then helper
func (mmRetrieveOrCreate *mUserRepositoryMockRetrieveOrCreate) When(ctx context.Context, user *domain.User) *UserRepositoryMockRetrieveOrCreateExpectation {
	if mmRetrieveOrCreate.mock.funcRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("UserRepositoryMock.RetrieveOrCreate mock is already set by Set")
	}

	expectation := &UserRepositoryMockRetrieveOrCreateExpectation{
		mock:   mmRetrieveOrCreate.mock,
		params: &UserRepositoryMockRetrieveOrCreateParams{ctx, user},
	}
	mmRetrieveOrCreate.expectations = append(mmRetrieveOrCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.RetrieveOrCreate return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockRetrieveOrCreateExpectation) Then(u1 domain.UserRetrieve) *UserRepositoryMock {
	e.results = &UserRepositoryMockRetrieveOrCreateResults{u1}
	return e.mock
}

// RetrieveOrCreate implements UserRepository
func (mmRetrieveOrCreate *UserRepositoryMock) RetrieveOrCreate(ctx context.Context, user *domain.User) (u1 domain.UserRetrieve) {
	mm_atomic.AddUint64(&mmRetrieveOrCreate.beforeRetrieveOrCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrieveOrCreate.afterRetrieveOrCreateCounter, 1)

	if mmRetrieveOrCreate.inspectFuncRetrieveOrCreate != nil {
		mmRetrieveOrCreate.inspectFuncRetrieveOrCreate(ctx, user)
	}

	mm_params := &UserRepositoryMockRetrieveOrCreateParams{ctx, user}

	// Record call args
	mmRetrieveOrCreate.RetrieveOrCreateMock.mutex.Lock()
	mmRetrieveOrCreate.RetrieveOrCreateMock.callArgs = append(mmRetrieveOrCreate.RetrieveOrCreateMock.callArgs, mm_params)
	mmRetrieveOrCreate.RetrieveOrCreateMock.mutex.Unlock()

	for _, e := range mmRetrieveOrCreate.RetrieveOrCreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1
		}
	}

	if mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation.params
		mm_got := UserRepositoryMockRetrieveOrCreateParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrieveOrCreate.t.Errorf("UserRepositoryMock.RetrieveOrCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrieveOrCreate.t.Fatal("No results are set for the UserRepositoryMock.RetrieveOrCreate")
		}
		return (*mm_results).u1
	}
	if mmRetrieveOrCreate.funcRetrieveOrCreate != nil {
		return mmRetrieveOrCreate.funcRetrieveOrCreate(ctx, user)
	}
	mmRetrieveOrCreate.t.Fatalf("Unexpected call to UserRepositoryMock.RetrieveOrCreate. %v %v", ctx, user)
	return
}

// RetrieveOrCreateAfterCounter returns a count of finished UserRepositoryMock.RetrieveOrCreate invocations
func (mmRetrieveOrCreate *UserRepositoryMock) RetrieveOrCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveOrCreate.afterRetrieveOrCreateCounter)
}

// RetrieveOrCreateBeforeCounter returns a count of UserRepositoryMock.RetrieveOrCreate invocations
func (mmRetrieveOrCreate *UserRepositoryMock) RetrieveOrCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveOrCreate.beforeRetrieveOrCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.RetrieveOrCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrieveOrCreate *mUserRepositoryMockRetrieveOrCreate) Calls() []*UserRepositoryMockRetrieveOrCreateParams {
	mmRetrieveOrCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockRetrieveOrCreateParams, len(mmRetrieveOrCreate.callArgs))
	copy(argCopy, mmRetrieveOrCreate.callArgs)

	mmRetrieveOrCreate.mutex.RUnlock()

	return argCopy
}

// MinimockRetrieveOrCreateDone returns true if the count of the RetrieveOrCreate invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockRetrieveOrCreateDone() bool {
	for _, e := range m.RetrieveOrCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveOrCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveOrCreate != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrieveOrCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockRetrieveOrCreateInspect() {
	for _, e := range m.RetrieveOrCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.RetrieveOrCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveOrCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		if m.RetrieveOrCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.RetrieveOrCreate")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.RetrieveOrCreate with params: %#v", *m.RetrieveOrCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveOrCreate != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.RetrieveOrCreate")
	}
}

type mUserRepositoryMockUpdate struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateExpectation
	expectations       []*UserRepositoryMockUpdateExpectation

	callArgs []*UserRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// UserRepositoryMockUpdateExpectation specifies expectation struct of the UserRepository.Update
type UserRepositoryMockUpdateExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockUpdateParams
	results *UserRepositoryMockUpdateResults
	Counter uint64
}

// UserRepositoryMockUpdateParams contains parameters of the UserRepository.Update
type UserRepositoryMockUpdateParams struct {
	ctx  context.Context
	user *domain.User
}

// UserRepositoryMockUpdateResults contains results of the UserRepository.Update
type UserRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Expect(ctx context.Context, user *domain.User) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &UserRepositoryMockUpdateParams{ctx, user}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, user *domain.User)) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Return(err error) *UserRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

//Set uses given function f to mock the UserRepository.Update method
func (mmUpdate *mUserRepositoryMockUpdate) Set(f func(ctx context.Context, user *domain.User) (err error)) *UserRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the UserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserRepositoryMockUpdate) When(ctx context.Context, user *domain.User) *UserRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &UserRepositoryMockUpdateParams{ctx, user},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements UserRepository
func (mmUpdate *UserRepositoryMock) Update(ctx context.Context, user *domain.User) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, user)
	}

	mm_params := &UserRepositoryMockUpdateParams{ctx, user}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := UserRepositoryMockUpdateParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, user)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserRepositoryMock.Update. %v %v", ctx, user)
	return
}

// UpdateAfterCounter returns a count of finished UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserRepositoryMockUpdate) Calls() []*UserRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockRetrieveInspect()

		m.MinimockRetrieveOrCreateInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockRetrieveDone() &&
		m.MinimockRetrieveOrCreateDone() &&
		m.MinimockUpdateDone()
}
