package mock_repository

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/abrbird/portfolio_bot/internal/repository.Repository -o ./repository_mock_test.go -n RepositoryMock

import (
	"github.com/abrbird/portfolio_bot/internal/repository"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCurrency          func() (c1 repository.CurrencyRepository)
	inspectFuncCurrency   func()
	afterCurrencyCounter  uint64
	beforeCurrencyCounter uint64
	CurrencyMock          mRepositoryMockCurrency

	funcMarketItem          func() (m1 repository.MarketItemRepository)
	inspectFuncMarketItem   func()
	afterMarketItemCounter  uint64
	beforeMarketItemCounter uint64
	MarketItemMock          mRepositoryMockMarketItem

	funcMarketPrice          func() (m1 repository.MarketPriceRepository)
	inspectFuncMarketPrice   func()
	afterMarketPriceCounter  uint64
	beforeMarketPriceCounter uint64
	MarketPriceMock          mRepositoryMockMarketPrice

	funcPortfolio          func() (p1 repository.PortfolioRepository)
	inspectFuncPortfolio   func()
	afterPortfolioCounter  uint64
	beforePortfolioCounter uint64
	PortfolioMock          mRepositoryMockPortfolio

	funcPortfolioItem          func() (p1 repository.PortfolioItemRepository)
	inspectFuncPortfolioItem   func()
	afterPortfolioItemCounter  uint64
	beforePortfolioItemCounter uint64
	PortfolioItemMock          mRepositoryMockPortfolioItem

	funcUser          func() (u1 repository.UserRepository)
	inspectFuncUser   func()
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mRepositoryMockUser
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CurrencyMock = mRepositoryMockCurrency{mock: m}

	m.MarketItemMock = mRepositoryMockMarketItem{mock: m}

	m.MarketPriceMock = mRepositoryMockMarketPrice{mock: m}

	m.PortfolioMock = mRepositoryMockPortfolio{mock: m}

	m.PortfolioItemMock = mRepositoryMockPortfolioItem{mock: m}

	m.UserMock = mRepositoryMockUser{mock: m}

	return m
}

type mRepositoryMockCurrency struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCurrencyExpectation
	expectations       []*RepositoryMockCurrencyExpectation
}

// RepositoryMockCurrencyExpectation specifies expectation struct of the Repository.Currency
type RepositoryMockCurrencyExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockCurrencyResults
	Counter uint64
}

// RepositoryMockCurrencyResults contains results of the Repository.Currency
type RepositoryMockCurrencyResults struct {
	c1 repository.CurrencyRepository
}

// Expect sets up expected params for Repository.Currency
func (mmCurrency *mRepositoryMockCurrency) Expect() *mRepositoryMockCurrency {
	if mmCurrency.mock.funcCurrency != nil {
		mmCurrency.mock.t.Fatalf("RepositoryMock.Currency mock is already set by Set")
	}

	if mmCurrency.defaultExpectation == nil {
		mmCurrency.defaultExpectation = &RepositoryMockCurrencyExpectation{}
	}

	return mmCurrency
}

// Inspect accepts an inspector function that has same arguments as the Repository.Currency
func (mmCurrency *mRepositoryMockCurrency) Inspect(f func()) *mRepositoryMockCurrency {
	if mmCurrency.mock.inspectFuncCurrency != nil {
		mmCurrency.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Currency")
	}

	mmCurrency.mock.inspectFuncCurrency = f

	return mmCurrency
}

// Return sets up results that will be returned by Repository.Currency
func (mmCurrency *mRepositoryMockCurrency) Return(c1 repository.CurrencyRepository) *RepositoryMock {
	if mmCurrency.mock.funcCurrency != nil {
		mmCurrency.mock.t.Fatalf("RepositoryMock.Currency mock is already set by Set")
	}

	if mmCurrency.defaultExpectation == nil {
		mmCurrency.defaultExpectation = &RepositoryMockCurrencyExpectation{mock: mmCurrency.mock}
	}
	mmCurrency.defaultExpectation.results = &RepositoryMockCurrencyResults{c1}
	return mmCurrency.mock
}

//Set uses given function f to mock the Repository.Currency method
func (mmCurrency *mRepositoryMockCurrency) Set(f func() (c1 repository.CurrencyRepository)) *RepositoryMock {
	if mmCurrency.defaultExpectation != nil {
		mmCurrency.mock.t.Fatalf("Default expectation is already set for the Repository.Currency method")
	}

	if len(mmCurrency.expectations) > 0 {
		mmCurrency.mock.t.Fatalf("Some expectations are already set for the Repository.Currency method")
	}

	mmCurrency.mock.funcCurrency = f
	return mmCurrency.mock
}

// Currency implements Repository
func (mmCurrency *RepositoryMock) Currency() (c1 repository.CurrencyRepository) {
	mm_atomic.AddUint64(&mmCurrency.beforeCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmCurrency.afterCurrencyCounter, 1)

	if mmCurrency.inspectFuncCurrency != nil {
		mmCurrency.inspectFuncCurrency()
	}

	if mmCurrency.CurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCurrency.CurrencyMock.defaultExpectation.Counter, 1)

		mm_results := mmCurrency.CurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmCurrency.t.Fatal("No results are set for the RepositoryMock.Currency")
		}
		return (*mm_results).c1
	}
	if mmCurrency.funcCurrency != nil {
		return mmCurrency.funcCurrency()
	}
	mmCurrency.t.Fatalf("Unexpected call to RepositoryMock.Currency.")
	return
}

// CurrencyAfterCounter returns a count of finished RepositoryMock.Currency invocations
func (mmCurrency *RepositoryMock) CurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCurrency.afterCurrencyCounter)
}

// CurrencyBeforeCounter returns a count of RepositoryMock.Currency invocations
func (mmCurrency *RepositoryMock) CurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCurrency.beforeCurrencyCounter)
}

// MinimockCurrencyDone returns true if the count of the Currency invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCurrencyDone() bool {
	for _, e := range m.CurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCurrency != nil && mm_atomic.LoadUint64(&m.afterCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCurrencyInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCurrencyInspect() {
	for _, e := range m.CurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Currency")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCurrencyCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Currency")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCurrency != nil && mm_atomic.LoadUint64(&m.afterCurrencyCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Currency")
	}
}

type mRepositoryMockMarketItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockMarketItemExpectation
	expectations       []*RepositoryMockMarketItemExpectation
}

// RepositoryMockMarketItemExpectation specifies expectation struct of the Repository.MarketItem
type RepositoryMockMarketItemExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockMarketItemResults
	Counter uint64
}

// RepositoryMockMarketItemResults contains results of the Repository.MarketItem
type RepositoryMockMarketItemResults struct {
	m1 repository.MarketItemRepository
}

// Expect sets up expected params for Repository.MarketItem
func (mmMarketItem *mRepositoryMockMarketItem) Expect() *mRepositoryMockMarketItem {
	if mmMarketItem.mock.funcMarketItem != nil {
		mmMarketItem.mock.t.Fatalf("RepositoryMock.MarketItem mock is already set by Set")
	}

	if mmMarketItem.defaultExpectation == nil {
		mmMarketItem.defaultExpectation = &RepositoryMockMarketItemExpectation{}
	}

	return mmMarketItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.MarketItem
func (mmMarketItem *mRepositoryMockMarketItem) Inspect(f func()) *mRepositoryMockMarketItem {
	if mmMarketItem.mock.inspectFuncMarketItem != nil {
		mmMarketItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.MarketItem")
	}

	mmMarketItem.mock.inspectFuncMarketItem = f

	return mmMarketItem
}

// Return sets up results that will be returned by Repository.MarketItem
func (mmMarketItem *mRepositoryMockMarketItem) Return(m1 repository.MarketItemRepository) *RepositoryMock {
	if mmMarketItem.mock.funcMarketItem != nil {
		mmMarketItem.mock.t.Fatalf("RepositoryMock.MarketItem mock is already set by Set")
	}

	if mmMarketItem.defaultExpectation == nil {
		mmMarketItem.defaultExpectation = &RepositoryMockMarketItemExpectation{mock: mmMarketItem.mock}
	}
	mmMarketItem.defaultExpectation.results = &RepositoryMockMarketItemResults{m1}
	return mmMarketItem.mock
}

//Set uses given function f to mock the Repository.MarketItem method
func (mmMarketItem *mRepositoryMockMarketItem) Set(f func() (m1 repository.MarketItemRepository)) *RepositoryMock {
	if mmMarketItem.defaultExpectation != nil {
		mmMarketItem.mock.t.Fatalf("Default expectation is already set for the Repository.MarketItem method")
	}

	if len(mmMarketItem.expectations) > 0 {
		mmMarketItem.mock.t.Fatalf("Some expectations are already set for the Repository.MarketItem method")
	}

	mmMarketItem.mock.funcMarketItem = f
	return mmMarketItem.mock
}

// MarketItem implements Repository
func (mmMarketItem *RepositoryMock) MarketItem() (m1 repository.MarketItemRepository) {
	mm_atomic.AddUint64(&mmMarketItem.beforeMarketItemCounter, 1)
	defer mm_atomic.AddUint64(&mmMarketItem.afterMarketItemCounter, 1)

	if mmMarketItem.inspectFuncMarketItem != nil {
		mmMarketItem.inspectFuncMarketItem()
	}

	if mmMarketItem.MarketItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarketItem.MarketItemMock.defaultExpectation.Counter, 1)

		mm_results := mmMarketItem.MarketItemMock.defaultExpectation.results
		if mm_results == nil {
			mmMarketItem.t.Fatal("No results are set for the RepositoryMock.MarketItem")
		}
		return (*mm_results).m1
	}
	if mmMarketItem.funcMarketItem != nil {
		return mmMarketItem.funcMarketItem()
	}
	mmMarketItem.t.Fatalf("Unexpected call to RepositoryMock.MarketItem.")
	return
}

// MarketItemAfterCounter returns a count of finished RepositoryMock.MarketItem invocations
func (mmMarketItem *RepositoryMock) MarketItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarketItem.afterMarketItemCounter)
}

// MarketItemBeforeCounter returns a count of RepositoryMock.MarketItem invocations
func (mmMarketItem *RepositoryMock) MarketItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarketItem.beforeMarketItemCounter)
}

// MinimockMarketItemDone returns true if the count of the MarketItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockMarketItemDone() bool {
	for _, e := range m.MarketItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarketItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarketItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarketItem != nil && mm_atomic.LoadUint64(&m.afterMarketItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockMarketItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockMarketItemInspect() {
	for _, e := range m.MarketItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.MarketItem")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarketItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarketItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.MarketItem")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarketItem != nil && mm_atomic.LoadUint64(&m.afterMarketItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.MarketItem")
	}
}

type mRepositoryMockMarketPrice struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockMarketPriceExpectation
	expectations       []*RepositoryMockMarketPriceExpectation
}

// RepositoryMockMarketPriceExpectation specifies expectation struct of the Repository.MarketPrice
type RepositoryMockMarketPriceExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockMarketPriceResults
	Counter uint64
}

// RepositoryMockMarketPriceResults contains results of the Repository.MarketPrice
type RepositoryMockMarketPriceResults struct {
	m1 repository.MarketPriceRepository
}

// Expect sets up expected params for Repository.MarketPrice
func (mmMarketPrice *mRepositoryMockMarketPrice) Expect() *mRepositoryMockMarketPrice {
	if mmMarketPrice.mock.funcMarketPrice != nil {
		mmMarketPrice.mock.t.Fatalf("RepositoryMock.MarketPrice mock is already set by Set")
	}

	if mmMarketPrice.defaultExpectation == nil {
		mmMarketPrice.defaultExpectation = &RepositoryMockMarketPriceExpectation{}
	}

	return mmMarketPrice
}

// Inspect accepts an inspector function that has same arguments as the Repository.MarketPrice
func (mmMarketPrice *mRepositoryMockMarketPrice) Inspect(f func()) *mRepositoryMockMarketPrice {
	if mmMarketPrice.mock.inspectFuncMarketPrice != nil {
		mmMarketPrice.mock.t.Fatalf("Inspect function is already set for RepositoryMock.MarketPrice")
	}

	mmMarketPrice.mock.inspectFuncMarketPrice = f

	return mmMarketPrice
}

// Return sets up results that will be returned by Repository.MarketPrice
func (mmMarketPrice *mRepositoryMockMarketPrice) Return(m1 repository.MarketPriceRepository) *RepositoryMock {
	if mmMarketPrice.mock.funcMarketPrice != nil {
		mmMarketPrice.mock.t.Fatalf("RepositoryMock.MarketPrice mock is already set by Set")
	}

	if mmMarketPrice.defaultExpectation == nil {
		mmMarketPrice.defaultExpectation = &RepositoryMockMarketPriceExpectation{mock: mmMarketPrice.mock}
	}
	mmMarketPrice.defaultExpectation.results = &RepositoryMockMarketPriceResults{m1}
	return mmMarketPrice.mock
}

//Set uses given function f to mock the Repository.MarketPrice method
func (mmMarketPrice *mRepositoryMockMarketPrice) Set(f func() (m1 repository.MarketPriceRepository)) *RepositoryMock {
	if mmMarketPrice.defaultExpectation != nil {
		mmMarketPrice.mock.t.Fatalf("Default expectation is already set for the Repository.MarketPrice method")
	}

	if len(mmMarketPrice.expectations) > 0 {
		mmMarketPrice.mock.t.Fatalf("Some expectations are already set for the Repository.MarketPrice method")
	}

	mmMarketPrice.mock.funcMarketPrice = f
	return mmMarketPrice.mock
}

// MarketPrice implements Repository
func (mmMarketPrice *RepositoryMock) MarketPrice() (m1 repository.MarketPriceRepository) {
	mm_atomic.AddUint64(&mmMarketPrice.beforeMarketPriceCounter, 1)
	defer mm_atomic.AddUint64(&mmMarketPrice.afterMarketPriceCounter, 1)

	if mmMarketPrice.inspectFuncMarketPrice != nil {
		mmMarketPrice.inspectFuncMarketPrice()
	}

	if mmMarketPrice.MarketPriceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarketPrice.MarketPriceMock.defaultExpectation.Counter, 1)

		mm_results := mmMarketPrice.MarketPriceMock.defaultExpectation.results
		if mm_results == nil {
			mmMarketPrice.t.Fatal("No results are set for the RepositoryMock.MarketPrice")
		}
		return (*mm_results).m1
	}
	if mmMarketPrice.funcMarketPrice != nil {
		return mmMarketPrice.funcMarketPrice()
	}
	mmMarketPrice.t.Fatalf("Unexpected call to RepositoryMock.MarketPrice.")
	return
}

// MarketPriceAfterCounter returns a count of finished RepositoryMock.MarketPrice invocations
func (mmMarketPrice *RepositoryMock) MarketPriceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarketPrice.afterMarketPriceCounter)
}

// MarketPriceBeforeCounter returns a count of RepositoryMock.MarketPrice invocations
func (mmMarketPrice *RepositoryMock) MarketPriceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarketPrice.beforeMarketPriceCounter)
}

// MinimockMarketPriceDone returns true if the count of the MarketPrice invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockMarketPriceDone() bool {
	for _, e := range m.MarketPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarketPriceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarketPriceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarketPrice != nil && mm_atomic.LoadUint64(&m.afterMarketPriceCounter) < 1 {
		return false
	}
	return true
}

// MinimockMarketPriceInspect logs each unmet expectation
func (m *RepositoryMock) MinimockMarketPriceInspect() {
	for _, e := range m.MarketPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.MarketPrice")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MarketPriceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMarketPriceCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.MarketPrice")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarketPrice != nil && mm_atomic.LoadUint64(&m.afterMarketPriceCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.MarketPrice")
	}
}

type mRepositoryMockPortfolio struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockPortfolioExpectation
	expectations       []*RepositoryMockPortfolioExpectation
}

// RepositoryMockPortfolioExpectation specifies expectation struct of the Repository.Portfolio
type RepositoryMockPortfolioExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockPortfolioResults
	Counter uint64
}

// RepositoryMockPortfolioResults contains results of the Repository.Portfolio
type RepositoryMockPortfolioResults struct {
	p1 repository.PortfolioRepository
}

// Expect sets up expected params for Repository.Portfolio
func (mmPortfolio *mRepositoryMockPortfolio) Expect() *mRepositoryMockPortfolio {
	if mmPortfolio.mock.funcPortfolio != nil {
		mmPortfolio.mock.t.Fatalf("RepositoryMock.Portfolio mock is already set by Set")
	}

	if mmPortfolio.defaultExpectation == nil {
		mmPortfolio.defaultExpectation = &RepositoryMockPortfolioExpectation{}
	}

	return mmPortfolio
}

// Inspect accepts an inspector function that has same arguments as the Repository.Portfolio
func (mmPortfolio *mRepositoryMockPortfolio) Inspect(f func()) *mRepositoryMockPortfolio {
	if mmPortfolio.mock.inspectFuncPortfolio != nil {
		mmPortfolio.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Portfolio")
	}

	mmPortfolio.mock.inspectFuncPortfolio = f

	return mmPortfolio
}

// Return sets up results that will be returned by Repository.Portfolio
func (mmPortfolio *mRepositoryMockPortfolio) Return(p1 repository.PortfolioRepository) *RepositoryMock {
	if mmPortfolio.mock.funcPortfolio != nil {
		mmPortfolio.mock.t.Fatalf("RepositoryMock.Portfolio mock is already set by Set")
	}

	if mmPortfolio.defaultExpectation == nil {
		mmPortfolio.defaultExpectation = &RepositoryMockPortfolioExpectation{mock: mmPortfolio.mock}
	}
	mmPortfolio.defaultExpectation.results = &RepositoryMockPortfolioResults{p1}
	return mmPortfolio.mock
}

//Set uses given function f to mock the Repository.Portfolio method
func (mmPortfolio *mRepositoryMockPortfolio) Set(f func() (p1 repository.PortfolioRepository)) *RepositoryMock {
	if mmPortfolio.defaultExpectation != nil {
		mmPortfolio.mock.t.Fatalf("Default expectation is already set for the Repository.Portfolio method")
	}

	if len(mmPortfolio.expectations) > 0 {
		mmPortfolio.mock.t.Fatalf("Some expectations are already set for the Repository.Portfolio method")
	}

	mmPortfolio.mock.funcPortfolio = f
	return mmPortfolio.mock
}

// Portfolio implements Repository
func (mmPortfolio *RepositoryMock) Portfolio() (p1 repository.PortfolioRepository) {
	mm_atomic.AddUint64(&mmPortfolio.beforePortfolioCounter, 1)
	defer mm_atomic.AddUint64(&mmPortfolio.afterPortfolioCounter, 1)

	if mmPortfolio.inspectFuncPortfolio != nil {
		mmPortfolio.inspectFuncPortfolio()
	}

	if mmPortfolio.PortfolioMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPortfolio.PortfolioMock.defaultExpectation.Counter, 1)

		mm_results := mmPortfolio.PortfolioMock.defaultExpectation.results
		if mm_results == nil {
			mmPortfolio.t.Fatal("No results are set for the RepositoryMock.Portfolio")
		}
		return (*mm_results).p1
	}
	if mmPortfolio.funcPortfolio != nil {
		return mmPortfolio.funcPortfolio()
	}
	mmPortfolio.t.Fatalf("Unexpected call to RepositoryMock.Portfolio.")
	return
}

// PortfolioAfterCounter returns a count of finished RepositoryMock.Portfolio invocations
func (mmPortfolio *RepositoryMock) PortfolioAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPortfolio.afterPortfolioCounter)
}

// PortfolioBeforeCounter returns a count of RepositoryMock.Portfolio invocations
func (mmPortfolio *RepositoryMock) PortfolioBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPortfolio.beforePortfolioCounter)
}

// MinimockPortfolioDone returns true if the count of the Portfolio invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockPortfolioDone() bool {
	for _, e := range m.PortfolioMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PortfolioMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPortfolioCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPortfolio != nil && mm_atomic.LoadUint64(&m.afterPortfolioCounter) < 1 {
		return false
	}
	return true
}

// MinimockPortfolioInspect logs each unmet expectation
func (m *RepositoryMock) MinimockPortfolioInspect() {
	for _, e := range m.PortfolioMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Portfolio")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PortfolioMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPortfolioCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Portfolio")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPortfolio != nil && mm_atomic.LoadUint64(&m.afterPortfolioCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Portfolio")
	}
}

type mRepositoryMockPortfolioItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockPortfolioItemExpectation
	expectations       []*RepositoryMockPortfolioItemExpectation
}

// RepositoryMockPortfolioItemExpectation specifies expectation struct of the Repository.PortfolioItem
type RepositoryMockPortfolioItemExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockPortfolioItemResults
	Counter uint64
}

// RepositoryMockPortfolioItemResults contains results of the Repository.PortfolioItem
type RepositoryMockPortfolioItemResults struct {
	p1 repository.PortfolioItemRepository
}

// Expect sets up expected params for Repository.PortfolioItem
func (mmPortfolioItem *mRepositoryMockPortfolioItem) Expect() *mRepositoryMockPortfolioItem {
	if mmPortfolioItem.mock.funcPortfolioItem != nil {
		mmPortfolioItem.mock.t.Fatalf("RepositoryMock.PortfolioItem mock is already set by Set")
	}

	if mmPortfolioItem.defaultExpectation == nil {
		mmPortfolioItem.defaultExpectation = &RepositoryMockPortfolioItemExpectation{}
	}

	return mmPortfolioItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.PortfolioItem
func (mmPortfolioItem *mRepositoryMockPortfolioItem) Inspect(f func()) *mRepositoryMockPortfolioItem {
	if mmPortfolioItem.mock.inspectFuncPortfolioItem != nil {
		mmPortfolioItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.PortfolioItem")
	}

	mmPortfolioItem.mock.inspectFuncPortfolioItem = f

	return mmPortfolioItem
}

// Return sets up results that will be returned by Repository.PortfolioItem
func (mmPortfolioItem *mRepositoryMockPortfolioItem) Return(p1 repository.PortfolioItemRepository) *RepositoryMock {
	if mmPortfolioItem.mock.funcPortfolioItem != nil {
		mmPortfolioItem.mock.t.Fatalf("RepositoryMock.PortfolioItem mock is already set by Set")
	}

	if mmPortfolioItem.defaultExpectation == nil {
		mmPortfolioItem.defaultExpectation = &RepositoryMockPortfolioItemExpectation{mock: mmPortfolioItem.mock}
	}
	mmPortfolioItem.defaultExpectation.results = &RepositoryMockPortfolioItemResults{p1}
	return mmPortfolioItem.mock
}

//Set uses given function f to mock the Repository.PortfolioItem method
func (mmPortfolioItem *mRepositoryMockPortfolioItem) Set(f func() (p1 repository.PortfolioItemRepository)) *RepositoryMock {
	if mmPortfolioItem.defaultExpectation != nil {
		mmPortfolioItem.mock.t.Fatalf("Default expectation is already set for the Repository.PortfolioItem method")
	}

	if len(mmPortfolioItem.expectations) > 0 {
		mmPortfolioItem.mock.t.Fatalf("Some expectations are already set for the Repository.PortfolioItem method")
	}

	mmPortfolioItem.mock.funcPortfolioItem = f
	return mmPortfolioItem.mock
}

// PortfolioItem implements Repository
func (mmPortfolioItem *RepositoryMock) PortfolioItem() (p1 repository.PortfolioItemRepository) {
	mm_atomic.AddUint64(&mmPortfolioItem.beforePortfolioItemCounter, 1)
	defer mm_atomic.AddUint64(&mmPortfolioItem.afterPortfolioItemCounter, 1)

	if mmPortfolioItem.inspectFuncPortfolioItem != nil {
		mmPortfolioItem.inspectFuncPortfolioItem()
	}

	if mmPortfolioItem.PortfolioItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPortfolioItem.PortfolioItemMock.defaultExpectation.Counter, 1)

		mm_results := mmPortfolioItem.PortfolioItemMock.defaultExpectation.results
		if mm_results == nil {
			mmPortfolioItem.t.Fatal("No results are set for the RepositoryMock.PortfolioItem")
		}
		return (*mm_results).p1
	}
	if mmPortfolioItem.funcPortfolioItem != nil {
		return mmPortfolioItem.funcPortfolioItem()
	}
	mmPortfolioItem.t.Fatalf("Unexpected call to RepositoryMock.PortfolioItem.")
	return
}

// PortfolioItemAfterCounter returns a count of finished RepositoryMock.PortfolioItem invocations
func (mmPortfolioItem *RepositoryMock) PortfolioItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPortfolioItem.afterPortfolioItemCounter)
}

// PortfolioItemBeforeCounter returns a count of RepositoryMock.PortfolioItem invocations
func (mmPortfolioItem *RepositoryMock) PortfolioItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPortfolioItem.beforePortfolioItemCounter)
}

// MinimockPortfolioItemDone returns true if the count of the PortfolioItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockPortfolioItemDone() bool {
	for _, e := range m.PortfolioItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PortfolioItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPortfolioItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPortfolioItem != nil && mm_atomic.LoadUint64(&m.afterPortfolioItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockPortfolioItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockPortfolioItemInspect() {
	for _, e := range m.PortfolioItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.PortfolioItem")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PortfolioItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPortfolioItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.PortfolioItem")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPortfolioItem != nil && mm_atomic.LoadUint64(&m.afterPortfolioItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.PortfolioItem")
	}
}

type mRepositoryMockUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserExpectation
	expectations       []*RepositoryMockUserExpectation
}

// RepositoryMockUserExpectation specifies expectation struct of the Repository.User
type RepositoryMockUserExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockUserResults
	Counter uint64
}

// RepositoryMockUserResults contains results of the Repository.User
type RepositoryMockUserResults struct {
	u1 repository.UserRepository
}

// Expect sets up expected params for Repository.User
func (mmUser *mRepositoryMockUser) Expect() *mRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{}
	}

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.User
func (mmUser *mRepositoryMockUser) Inspect(f func()) *mRepositoryMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by Repository.User
func (mmUser *mRepositoryMockUser) Return(u1 repository.UserRepository) *RepositoryMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("RepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &RepositoryMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &RepositoryMockUserResults{u1}
	return mmUser.mock
}

//Set uses given function f to mock the Repository.User method
func (mmUser *mRepositoryMockUser) Set(f func() (u1 repository.UserRepository)) *RepositoryMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the Repository.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the Repository.User method")
	}

	mmUser.mock.funcUser = f
	return mmUser.mock
}

// User implements Repository
func (mmUser *RepositoryMock) User() (u1 repository.UserRepository) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser()
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the RepositoryMock.User")
		}
		return (*mm_results).u1
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser()
	}
	mmUser.t.Fatalf("Unexpected call to RepositoryMock.User.")
	return
}

// UserAfterCounter returns a count of finished RepositoryMock.User invocations
func (mmUser *RepositoryMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of RepositoryMock.User invocations
func (mmUser *RepositoryMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserDone() bool {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && mm_atomic.LoadUint64(&m.afterUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.User")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.User")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && mm_atomic.LoadUint64(&m.afterUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.User")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCurrencyInspect()

		m.MinimockMarketItemInspect()

		m.MinimockMarketPriceInspect()

		m.MinimockPortfolioInspect()

		m.MinimockPortfolioItemInspect()

		m.MinimockUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCurrencyDone() &&
		m.MinimockMarketItemDone() &&
		m.MinimockMarketPriceDone() &&
		m.MinimockPortfolioDone() &&
		m.MinimockPortfolioItemDone() &&
		m.MinimockUserDone()
}
