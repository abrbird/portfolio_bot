package mock_repository

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/zBlur/homework-2/internal/repository.PortfolioRepository -o ./portfolio_repository_mock_test.go -n PortfolioRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/zBlur/homework-2/internal/domain"
)

// PortfolioRepositoryMock implements PortfolioRepository
type PortfolioRepositoryMock struct {
	t minimock.Tester

	funcRetrieve          func(ctx context.Context, userId domain.UserId) (p1 domain.PortfolioRetrieve)
	inspectFuncRetrieve   func(ctx context.Context, userId domain.UserId)
	afterRetrieveCounter  uint64
	beforeRetrieveCounter uint64
	RetrieveMock          mPortfolioRepositoryMockRetrieve

	funcRetrieveOrCreate          func(ctx context.Context, portfolioData domain.PortfolioCreate) (p1 domain.PortfolioRetrieve)
	inspectFuncRetrieveOrCreate   func(ctx context.Context, portfolioData domain.PortfolioCreate)
	afterRetrieveOrCreateCounter  uint64
	beforeRetrieveOrCreateCounter uint64
	RetrieveOrCreateMock          mPortfolioRepositoryMockRetrieveOrCreate
}

// NewPortfolioRepositoryMock returns a mock for PortfolioRepository
func NewPortfolioRepositoryMock(t minimock.Tester) *PortfolioRepositoryMock {
	m := &PortfolioRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RetrieveMock = mPortfolioRepositoryMockRetrieve{mock: m}
	m.RetrieveMock.callArgs = []*PortfolioRepositoryMockRetrieveParams{}

	m.RetrieveOrCreateMock = mPortfolioRepositoryMockRetrieveOrCreate{mock: m}
	m.RetrieveOrCreateMock.callArgs = []*PortfolioRepositoryMockRetrieveOrCreateParams{}

	return m
}

type mPortfolioRepositoryMockRetrieve struct {
	mock               *PortfolioRepositoryMock
	defaultExpectation *PortfolioRepositoryMockRetrieveExpectation
	expectations       []*PortfolioRepositoryMockRetrieveExpectation

	callArgs []*PortfolioRepositoryMockRetrieveParams
	mutex    sync.RWMutex
}

// PortfolioRepositoryMockRetrieveExpectation specifies expectation struct of the PortfolioRepository.Retrieve
type PortfolioRepositoryMockRetrieveExpectation struct {
	mock    *PortfolioRepositoryMock
	params  *PortfolioRepositoryMockRetrieveParams
	results *PortfolioRepositoryMockRetrieveResults
	Counter uint64
}

// PortfolioRepositoryMockRetrieveParams contains parameters of the PortfolioRepository.Retrieve
type PortfolioRepositoryMockRetrieveParams struct {
	ctx    context.Context
	userId domain.UserId
}

// PortfolioRepositoryMockRetrieveResults contains results of the PortfolioRepository.Retrieve
type PortfolioRepositoryMockRetrieveResults struct {
	p1 domain.PortfolioRetrieve
}

// Expect sets up expected params for PortfolioRepository.Retrieve
func (mmRetrieve *mPortfolioRepositoryMockRetrieve) Expect(ctx context.Context, userId domain.UserId) *mPortfolioRepositoryMockRetrieve {
	if mmRetrieve.mock.funcRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("PortfolioRepositoryMock.Retrieve mock is already set by Set")
	}

	if mmRetrieve.defaultExpectation == nil {
		mmRetrieve.defaultExpectation = &PortfolioRepositoryMockRetrieveExpectation{}
	}

	mmRetrieve.defaultExpectation.params = &PortfolioRepositoryMockRetrieveParams{ctx, userId}
	for _, e := range mmRetrieve.expectations {
		if minimock.Equal(e.params, mmRetrieve.defaultExpectation.params) {
			mmRetrieve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrieve.defaultExpectation.params)
		}
	}

	return mmRetrieve
}

// Inspect accepts an inspector function that has same arguments as the PortfolioRepository.Retrieve
func (mmRetrieve *mPortfolioRepositoryMockRetrieve) Inspect(f func(ctx context.Context, userId domain.UserId)) *mPortfolioRepositoryMockRetrieve {
	if mmRetrieve.mock.inspectFuncRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("Inspect function is already set for PortfolioRepositoryMock.Retrieve")
	}

	mmRetrieve.mock.inspectFuncRetrieve = f

	return mmRetrieve
}

// Return sets up results that will be returned by PortfolioRepository.Retrieve
func (mmRetrieve *mPortfolioRepositoryMockRetrieve) Return(p1 domain.PortfolioRetrieve) *PortfolioRepositoryMock {
	if mmRetrieve.mock.funcRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("PortfolioRepositoryMock.Retrieve mock is already set by Set")
	}

	if mmRetrieve.defaultExpectation == nil {
		mmRetrieve.defaultExpectation = &PortfolioRepositoryMockRetrieveExpectation{mock: mmRetrieve.mock}
	}
	mmRetrieve.defaultExpectation.results = &PortfolioRepositoryMockRetrieveResults{p1}
	return mmRetrieve.mock
}

//Set uses given function f to mock the PortfolioRepository.Retrieve method
func (mmRetrieve *mPortfolioRepositoryMockRetrieve) Set(f func(ctx context.Context, userId domain.UserId) (p1 domain.PortfolioRetrieve)) *PortfolioRepositoryMock {
	if mmRetrieve.defaultExpectation != nil {
		mmRetrieve.mock.t.Fatalf("Default expectation is already set for the PortfolioRepository.Retrieve method")
	}

	if len(mmRetrieve.expectations) > 0 {
		mmRetrieve.mock.t.Fatalf("Some expectations are already set for the PortfolioRepository.Retrieve method")
	}

	mmRetrieve.mock.funcRetrieve = f
	return mmRetrieve.mock
}

// When sets expectation for the PortfolioRepository.Retrieve which will trigger the result defined by the following
// Then helper
func (mmRetrieve *mPortfolioRepositoryMockRetrieve) When(ctx context.Context, userId domain.UserId) *PortfolioRepositoryMockRetrieveExpectation {
	if mmRetrieve.mock.funcRetrieve != nil {
		mmRetrieve.mock.t.Fatalf("PortfolioRepositoryMock.Retrieve mock is already set by Set")
	}

	expectation := &PortfolioRepositoryMockRetrieveExpectation{
		mock:   mmRetrieve.mock,
		params: &PortfolioRepositoryMockRetrieveParams{ctx, userId},
	}
	mmRetrieve.expectations = append(mmRetrieve.expectations, expectation)
	return expectation
}

// Then sets up PortfolioRepository.Retrieve return parameters for the expectation previously defined by the When method
func (e *PortfolioRepositoryMockRetrieveExpectation) Then(p1 domain.PortfolioRetrieve) *PortfolioRepositoryMock {
	e.results = &PortfolioRepositoryMockRetrieveResults{p1}
	return e.mock
}

// Retrieve implements PortfolioRepository
func (mmRetrieve *PortfolioRepositoryMock) Retrieve(ctx context.Context, userId domain.UserId) (p1 domain.PortfolioRetrieve) {
	mm_atomic.AddUint64(&mmRetrieve.beforeRetrieveCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrieve.afterRetrieveCounter, 1)

	if mmRetrieve.inspectFuncRetrieve != nil {
		mmRetrieve.inspectFuncRetrieve(ctx, userId)
	}

	mm_params := &PortfolioRepositoryMockRetrieveParams{ctx, userId}

	// Record call args
	mmRetrieve.RetrieveMock.mutex.Lock()
	mmRetrieve.RetrieveMock.callArgs = append(mmRetrieve.RetrieveMock.callArgs, mm_params)
	mmRetrieve.RetrieveMock.mutex.Unlock()

	for _, e := range mmRetrieve.RetrieveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmRetrieve.RetrieveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrieve.RetrieveMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrieve.RetrieveMock.defaultExpectation.params
		mm_got := PortfolioRepositoryMockRetrieveParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrieve.t.Errorf("PortfolioRepositoryMock.Retrieve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrieve.RetrieveMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrieve.t.Fatal("No results are set for the PortfolioRepositoryMock.Retrieve")
		}
		return (*mm_results).p1
	}
	if mmRetrieve.funcRetrieve != nil {
		return mmRetrieve.funcRetrieve(ctx, userId)
	}
	mmRetrieve.t.Fatalf("Unexpected call to PortfolioRepositoryMock.Retrieve. %v %v", ctx, userId)
	return
}

// RetrieveAfterCounter returns a count of finished PortfolioRepositoryMock.Retrieve invocations
func (mmRetrieve *PortfolioRepositoryMock) RetrieveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieve.afterRetrieveCounter)
}

// RetrieveBeforeCounter returns a count of PortfolioRepositoryMock.Retrieve invocations
func (mmRetrieve *PortfolioRepositoryMock) RetrieveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieve.beforeRetrieveCounter)
}

// Calls returns a list of arguments used in each call to PortfolioRepositoryMock.Retrieve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrieve *mPortfolioRepositoryMockRetrieve) Calls() []*PortfolioRepositoryMockRetrieveParams {
	mmRetrieve.mutex.RLock()

	argCopy := make([]*PortfolioRepositoryMockRetrieveParams, len(mmRetrieve.callArgs))
	copy(argCopy, mmRetrieve.callArgs)

	mmRetrieve.mutex.RUnlock()

	return argCopy
}

// MinimockRetrieveDone returns true if the count of the Retrieve invocations corresponds
// the number of defined expectations
func (m *PortfolioRepositoryMock) MinimockRetrieveDone() bool {
	for _, e := range m.RetrieveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieve != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrieveInspect logs each unmet expectation
func (m *PortfolioRepositoryMock) MinimockRetrieveInspect() {
	for _, e := range m.RetrieveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PortfolioRepositoryMock.Retrieve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		if m.RetrieveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PortfolioRepositoryMock.Retrieve")
		} else {
			m.t.Errorf("Expected call to PortfolioRepositoryMock.Retrieve with params: %#v", *m.RetrieveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieve != nil && mm_atomic.LoadUint64(&m.afterRetrieveCounter) < 1 {
		m.t.Error("Expected call to PortfolioRepositoryMock.Retrieve")
	}
}

type mPortfolioRepositoryMockRetrieveOrCreate struct {
	mock               *PortfolioRepositoryMock
	defaultExpectation *PortfolioRepositoryMockRetrieveOrCreateExpectation
	expectations       []*PortfolioRepositoryMockRetrieveOrCreateExpectation

	callArgs []*PortfolioRepositoryMockRetrieveOrCreateParams
	mutex    sync.RWMutex
}

// PortfolioRepositoryMockRetrieveOrCreateExpectation specifies expectation struct of the PortfolioRepository.RetrieveOrCreate
type PortfolioRepositoryMockRetrieveOrCreateExpectation struct {
	mock    *PortfolioRepositoryMock
	params  *PortfolioRepositoryMockRetrieveOrCreateParams
	results *PortfolioRepositoryMockRetrieveOrCreateResults
	Counter uint64
}

// PortfolioRepositoryMockRetrieveOrCreateParams contains parameters of the PortfolioRepository.RetrieveOrCreate
type PortfolioRepositoryMockRetrieveOrCreateParams struct {
	ctx           context.Context
	portfolioData domain.PortfolioCreate
}

// PortfolioRepositoryMockRetrieveOrCreateResults contains results of the PortfolioRepository.RetrieveOrCreate
type PortfolioRepositoryMockRetrieveOrCreateResults struct {
	p1 domain.PortfolioRetrieve
}

// Expect sets up expected params for PortfolioRepository.RetrieveOrCreate
func (mmRetrieveOrCreate *mPortfolioRepositoryMockRetrieveOrCreate) Expect(ctx context.Context, portfolioData domain.PortfolioCreate) *mPortfolioRepositoryMockRetrieveOrCreate {
	if mmRetrieveOrCreate.mock.funcRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("PortfolioRepositoryMock.RetrieveOrCreate mock is already set by Set")
	}

	if mmRetrieveOrCreate.defaultExpectation == nil {
		mmRetrieveOrCreate.defaultExpectation = &PortfolioRepositoryMockRetrieveOrCreateExpectation{}
	}

	mmRetrieveOrCreate.defaultExpectation.params = &PortfolioRepositoryMockRetrieveOrCreateParams{ctx, portfolioData}
	for _, e := range mmRetrieveOrCreate.expectations {
		if minimock.Equal(e.params, mmRetrieveOrCreate.defaultExpectation.params) {
			mmRetrieveOrCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrieveOrCreate.defaultExpectation.params)
		}
	}

	return mmRetrieveOrCreate
}

// Inspect accepts an inspector function that has same arguments as the PortfolioRepository.RetrieveOrCreate
func (mmRetrieveOrCreate *mPortfolioRepositoryMockRetrieveOrCreate) Inspect(f func(ctx context.Context, portfolioData domain.PortfolioCreate)) *mPortfolioRepositoryMockRetrieveOrCreate {
	if mmRetrieveOrCreate.mock.inspectFuncRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("Inspect function is already set for PortfolioRepositoryMock.RetrieveOrCreate")
	}

	mmRetrieveOrCreate.mock.inspectFuncRetrieveOrCreate = f

	return mmRetrieveOrCreate
}

// Return sets up results that will be returned by PortfolioRepository.RetrieveOrCreate
func (mmRetrieveOrCreate *mPortfolioRepositoryMockRetrieveOrCreate) Return(p1 domain.PortfolioRetrieve) *PortfolioRepositoryMock {
	if mmRetrieveOrCreate.mock.funcRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("PortfolioRepositoryMock.RetrieveOrCreate mock is already set by Set")
	}

	if mmRetrieveOrCreate.defaultExpectation == nil {
		mmRetrieveOrCreate.defaultExpectation = &PortfolioRepositoryMockRetrieveOrCreateExpectation{mock: mmRetrieveOrCreate.mock}
	}
	mmRetrieveOrCreate.defaultExpectation.results = &PortfolioRepositoryMockRetrieveOrCreateResults{p1}
	return mmRetrieveOrCreate.mock
}

//Set uses given function f to mock the PortfolioRepository.RetrieveOrCreate method
func (mmRetrieveOrCreate *mPortfolioRepositoryMockRetrieveOrCreate) Set(f func(ctx context.Context, portfolioData domain.PortfolioCreate) (p1 domain.PortfolioRetrieve)) *PortfolioRepositoryMock {
	if mmRetrieveOrCreate.defaultExpectation != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("Default expectation is already set for the PortfolioRepository.RetrieveOrCreate method")
	}

	if len(mmRetrieveOrCreate.expectations) > 0 {
		mmRetrieveOrCreate.mock.t.Fatalf("Some expectations are already set for the PortfolioRepository.RetrieveOrCreate method")
	}

	mmRetrieveOrCreate.mock.funcRetrieveOrCreate = f
	return mmRetrieveOrCreate.mock
}

// When sets expectation for the PortfolioRepository.RetrieveOrCreate which will trigger the result defined by the following
// Then helper
func (mmRetrieveOrCreate *mPortfolioRepositoryMockRetrieveOrCreate) When(ctx context.Context, portfolioData domain.PortfolioCreate) *PortfolioRepositoryMockRetrieveOrCreateExpectation {
	if mmRetrieveOrCreate.mock.funcRetrieveOrCreate != nil {
		mmRetrieveOrCreate.mock.t.Fatalf("PortfolioRepositoryMock.RetrieveOrCreate mock is already set by Set")
	}

	expectation := &PortfolioRepositoryMockRetrieveOrCreateExpectation{
		mock:   mmRetrieveOrCreate.mock,
		params: &PortfolioRepositoryMockRetrieveOrCreateParams{ctx, portfolioData},
	}
	mmRetrieveOrCreate.expectations = append(mmRetrieveOrCreate.expectations, expectation)
	return expectation
}

// Then sets up PortfolioRepository.RetrieveOrCreate return parameters for the expectation previously defined by the When method
func (e *PortfolioRepositoryMockRetrieveOrCreateExpectation) Then(p1 domain.PortfolioRetrieve) *PortfolioRepositoryMock {
	e.results = &PortfolioRepositoryMockRetrieveOrCreateResults{p1}
	return e.mock
}

// RetrieveOrCreate implements PortfolioRepository
func (mmRetrieveOrCreate *PortfolioRepositoryMock) RetrieveOrCreate(ctx context.Context, portfolioData domain.PortfolioCreate) (p1 domain.PortfolioRetrieve) {
	mm_atomic.AddUint64(&mmRetrieveOrCreate.beforeRetrieveOrCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrieveOrCreate.afterRetrieveOrCreateCounter, 1)

	if mmRetrieveOrCreate.inspectFuncRetrieveOrCreate != nil {
		mmRetrieveOrCreate.inspectFuncRetrieveOrCreate(ctx, portfolioData)
	}

	mm_params := &PortfolioRepositoryMockRetrieveOrCreateParams{ctx, portfolioData}

	// Record call args
	mmRetrieveOrCreate.RetrieveOrCreateMock.mutex.Lock()
	mmRetrieveOrCreate.RetrieveOrCreateMock.callArgs = append(mmRetrieveOrCreate.RetrieveOrCreateMock.callArgs, mm_params)
	mmRetrieveOrCreate.RetrieveOrCreateMock.mutex.Unlock()

	for _, e := range mmRetrieveOrCreate.RetrieveOrCreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation.params
		mm_got := PortfolioRepositoryMockRetrieveOrCreateParams{ctx, portfolioData}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrieveOrCreate.t.Errorf("PortfolioRepositoryMock.RetrieveOrCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrieveOrCreate.RetrieveOrCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrieveOrCreate.t.Fatal("No results are set for the PortfolioRepositoryMock.RetrieveOrCreate")
		}
		return (*mm_results).p1
	}
	if mmRetrieveOrCreate.funcRetrieveOrCreate != nil {
		return mmRetrieveOrCreate.funcRetrieveOrCreate(ctx, portfolioData)
	}
	mmRetrieveOrCreate.t.Fatalf("Unexpected call to PortfolioRepositoryMock.RetrieveOrCreate. %v %v", ctx, portfolioData)
	return
}

// RetrieveOrCreateAfterCounter returns a count of finished PortfolioRepositoryMock.RetrieveOrCreate invocations
func (mmRetrieveOrCreate *PortfolioRepositoryMock) RetrieveOrCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveOrCreate.afterRetrieveOrCreateCounter)
}

// RetrieveOrCreateBeforeCounter returns a count of PortfolioRepositoryMock.RetrieveOrCreate invocations
func (mmRetrieveOrCreate *PortfolioRepositoryMock) RetrieveOrCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrieveOrCreate.beforeRetrieveOrCreateCounter)
}

// Calls returns a list of arguments used in each call to PortfolioRepositoryMock.RetrieveOrCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrieveOrCreate *mPortfolioRepositoryMockRetrieveOrCreate) Calls() []*PortfolioRepositoryMockRetrieveOrCreateParams {
	mmRetrieveOrCreate.mutex.RLock()

	argCopy := make([]*PortfolioRepositoryMockRetrieveOrCreateParams, len(mmRetrieveOrCreate.callArgs))
	copy(argCopy, mmRetrieveOrCreate.callArgs)

	mmRetrieveOrCreate.mutex.RUnlock()

	return argCopy
}

// MinimockRetrieveOrCreateDone returns true if the count of the RetrieveOrCreate invocations corresponds
// the number of defined expectations
func (m *PortfolioRepositoryMock) MinimockRetrieveOrCreateDone() bool {
	for _, e := range m.RetrieveOrCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveOrCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveOrCreate != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrieveOrCreateInspect logs each unmet expectation
func (m *PortfolioRepositoryMock) MinimockRetrieveOrCreateInspect() {
	for _, e := range m.RetrieveOrCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PortfolioRepositoryMock.RetrieveOrCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrieveOrCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		if m.RetrieveOrCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PortfolioRepositoryMock.RetrieveOrCreate")
		} else {
			m.t.Errorf("Expected call to PortfolioRepositoryMock.RetrieveOrCreate with params: %#v", *m.RetrieveOrCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrieveOrCreate != nil && mm_atomic.LoadUint64(&m.afterRetrieveOrCreateCounter) < 1 {
		m.t.Error("Expected call to PortfolioRepositoryMock.RetrieveOrCreate")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PortfolioRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockRetrieveInspect()

		m.MinimockRetrieveOrCreateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PortfolioRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PortfolioRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRetrieveDone() &&
		m.MinimockRetrieveOrCreateDone()
}
